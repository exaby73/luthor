{
  "version": 3,
  "sources": ["../../hast-util-parse-selector/lib/index.js", "../../hastscript/lib/create-h.js", "../../hastscript/lib/svg-case-sensitive-tag-names.js", "../../hastscript/lib/index.js"],
  "sourcesContent": ["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: PropertyValue | Style}} Properties\n *   Acceptable value for element properties.\n *\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\nimport {parse as commas} from 'comma-separated-tokens'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {find, normalize} from 'property-information'\nimport {parse as spaces} from 'space-separated-tokens'\n\nconst buttonTypes = new Set(['button', 'menu', 'reset', 'submit'])\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {Array<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    let index = -1\n    /** @type {Result} */\n    let node\n\n    if (selector === undefined || selector === null) {\n      node = {type: 'root', children: []}\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */ (properties)\n      children.unshift(child)\n    } else {\n      node = parseSelector(selector, defaultTagName)\n      // Normalize the name.\n      node.tagName = node.tagName.toLowerCase()\n      if (adjust && own.call(adjust, node.tagName)) {\n        node.tagName = adjust[node.tagName]\n      }\n\n      // Handle props.\n      if (isProperties(properties, node.tagName)) {\n        /** @type {string} */\n        let key\n\n        for (key in properties) {\n          if (own.call(properties, key)) {\n            addProperty(schema, node.properties, key, properties[key])\n          }\n        }\n      } else {\n        children.unshift(properties)\n      }\n    }\n\n    // Handle children.\n    while (++index < children.length) {\n      addChild(node.children, children[index])\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {type: 'root', children: node.children}\n      node.children = []\n    }\n\n    return node\n  }\n\n  return h\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @param {string} name\n *   Tag name.\n * @returns {value is Properties}\n *   Whether `value` is a properties object.\n */\nfunction isProperties(value, name) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase())\n  }\n\n  return !('value' in value)\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {PropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // Assume no booleans in array.\n      const value = /** @type {number | string} */ (\n        parsePrimitive(info, info.property, result[index])\n      )\n      finalResult[index] = value\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    const value = /** @type {number | string} */ (result)\n    result = properties.className.concat(value)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n", "export const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n", "/**\n * @typedef {import('./create-h.js').Child} Child\n *   Acceptable child value.\n * @typedef {import('./create-h.js').Properties} Properties\n *   Acceptable value for element properties.\n * @typedef {import('./create-h.js').Result} Result\n *   Result from a `h` (or `s`) call.\n */\n\n// Register the JSX namespace on `h`.\n/**\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\n */\n\n// Register the JSX namespace on `s`.\n/**\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n */\n\nimport {html, svg} from 'property-information'\nimport {createH} from './create-h.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const h = createH(html, 'div')\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const s = createH(svg, 'g', svgCaseSensitiveTagNames)\n"],
  "mappings": "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",
  "names": ["h", "parse", "value"]
}
