import {
  EXIT,
  SKIP,
  visit
} from "./chunk-ZRYW4JRD.js";
import {
  whitespace,
  zwitch
} from "./chunk-CATREL2Z.js";
import {
  ok,
  unreachable
} from "./chunk-4JAOOOIH.js";
import {
  find,
  html,
  parse,
  parse2,
  stringify,
  stringify2,
  svg
} from "./chunk-6PIAH5PV.js";
import {
  toString
} from "./chunk-5LHU4J3J.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UV5CTPV7.js";

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/css-selector-parser/dist/mjs/indexes.js
var emptyMulticharIndex = {};
var emptyRegularIndex = {};
function extendIndex(item, index) {
  var currentIndex = index;
  for (var pos = 0; pos < item.length; pos++) {
    var isLast = pos === item.length - 1;
    var char = item.charAt(pos);
    var charIndex = currentIndex[char] || (currentIndex[char] = { chars: {} });
    if (isLast) {
      charIndex.self = item;
    }
    currentIndex = charIndex.chars;
  }
}
function createMulticharIndex(items) {
  if (items.length === 0) {
    return emptyMulticharIndex;
  }
  var index = {};
  for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
    var item = items_1[_i];
    extendIndex(item, index);
  }
  return index;
}
function createRegularIndex(items) {
  if (items.length === 0) {
    return emptyRegularIndex;
  }
  var result = {};
  for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
    var item = items_2[_i];
    result[item] = true;
  }
  return result;
}

// node_modules/css-selector-parser/dist/mjs/pseudo-signatures.js
var emptyPseudoSignatures = {};
var defaultPseudoSignature = {
  type: "String",
  optional: true
};
function calculatePseudoSignature(types) {
  var result = {
    type: "NoArgument",
    optional: false
  };
  function setResultType(type2) {
    if (result.type && result.type !== type2 && result.type !== "NoArgument") {
      throw new Error('Conflicting pseudo-class argument type: "'.concat(result.type, '" vs "').concat(type2, '".'));
    }
    result.type = type2;
  }
  for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
    var type = types_1[_i];
    if (type === "NoArgument") {
      result.optional = true;
    }
    if (type === "Formula") {
      setResultType("Formula");
    }
    if (type === "FormulaOfSelector") {
      setResultType("Formula");
      result.ofSelector = true;
    }
    if (type === "String") {
      setResultType("String");
    }
    if (type === "Selector") {
      setResultType("Selector");
    }
  }
  return result;
}
function inverseCategories(obj) {
  var result = {};
  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
    var category = _a[_i];
    var items = obj[category];
    if (items) {
      for (var _b = 0, _c = items; _b < _c.length; _b++) {
        var item = _c[_b];
        (result[item] || (result[item] = [])).push(category);
      }
    }
  }
  return result;
}
function calculatePseudoSignatures(definitions) {
  var pseudoClassesToArgumentTypes = inverseCategories(definitions);
  var result = {};
  for (var _i = 0, _a = Object.keys(pseudoClassesToArgumentTypes); _i < _a.length; _i++) {
    var pseudoClass = _a[_i];
    var argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];
    if (argumentTypes) {
      result[pseudoClass] = calculatePseudoSignature(argumentTypes);
    }
  }
  return result;
}

// node_modules/css-selector-parser/dist/mjs/syntax-definitions.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var emptyXmlOptions = {};
var defaultXmlOptions = { wildcard: true };
function getXmlOptions(param) {
  if (param) {
    if (typeof param === "boolean") {
      return defaultXmlOptions;
    } else {
      return param;
    }
  } else {
    return emptyXmlOptions;
  }
}
function withMigration(migration, merge) {
  return function(base, extension) {
    return merge(migration(base), migration(extension));
  };
}
function withNoNegative(merge) {
  return function(base, extension) {
    var result = merge(base, extension);
    if (!result) {
      throw new Error("Syntax definition cannot be null or undefined.");
    }
    return result;
  };
}
function withPositive(positive, merge) {
  return function(base, extension) {
    if (extension === true) {
      return positive;
    }
    return merge(base === true ? positive : base, extension);
  };
}
function mergeSection(values) {
  return function(base, extension) {
    if (!extension || !base) {
      return extension;
    }
    if (typeof extension !== "object" || extension === null) {
      throw new Error("Unexpected syntax definition extension type: ".concat(extension, "."));
    }
    var result = __assign({}, base);
    for (var _i = 0, _a = Object.entries(extension); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      var mergeSchema = values[key];
      result[key] = mergeSchema(base[key], value);
    }
    return result;
  };
}
function replaceValueIfSpecified(base, extension) {
  if (extension !== void 0) {
    return extension;
  }
  return base;
}
function concatArray(base, extension) {
  if (!extension) {
    return base;
  }
  if (!base) {
    return extension;
  }
  return base.concat(extension);
}
function mergeDefinitions(base, extension) {
  if (!extension) {
    return base;
  }
  if (!base) {
    return extension;
  }
  var result = __assign({}, base);
  for (var _i = 0, _a = Object.entries(extension); _i < _a.length; _i++) {
    var _b = _a[_i], key = _b[0], value = _b[1];
    if (!value) {
      delete result[key];
      continue;
    }
    var baseValue = base[key];
    if (!baseValue) {
      result[key] = value;
      continue;
    }
    result[key] = baseValue.concat(value);
  }
  return result;
}
var extendSyntaxDefinition = withNoNegative(mergeSection({
  baseSyntax: replaceValueIfSpecified,
  tag: withPositive(defaultXmlOptions, mergeSection({
    wildcard: replaceValueIfSpecified
  })),
  ids: replaceValueIfSpecified,
  classNames: replaceValueIfSpecified,
  namespace: withPositive(defaultXmlOptions, mergeSection({
    wildcard: replaceValueIfSpecified
  })),
  combinators: concatArray,
  attributes: mergeSection({
    operators: concatArray,
    caseSensitivityModifiers: concatArray,
    unknownCaseSensitivityModifiers: replaceValueIfSpecified
  }),
  pseudoClasses: mergeSection({
    unknown: replaceValueIfSpecified,
    definitions: mergeDefinitions
  }),
  pseudoElements: mergeSection({
    unknown: replaceValueIfSpecified,
    notation: replaceValueIfSpecified,
    definitions: withMigration(function(definitions) {
      return Array.isArray(definitions) ? { NoArgument: definitions } : definitions;
    }, mergeDefinitions)
  })
}));
var css1SyntaxDefinition = {
  tag: {},
  ids: true,
  classNames: true,
  combinators: [],
  pseudoElements: {
    unknown: "reject",
    notation: "singleColon",
    definitions: ["first-letter", "first-line"]
  },
  pseudoClasses: {
    unknown: "reject",
    definitions: {
      NoArgument: ["link", "visited", "active"]
    }
  }
};
var css2SyntaxDefinition = extendSyntaxDefinition(css1SyntaxDefinition, {
  tag: { wildcard: true },
  combinators: [">", "+"],
  attributes: {
    unknownCaseSensitivityModifiers: "reject",
    operators: ["=", "~=", "|="]
  },
  pseudoElements: {
    definitions: ["before", "after"]
  },
  pseudoClasses: {
    unknown: "reject",
    definitions: {
      NoArgument: ["hover", "focus", "first-child"],
      String: ["lang"]
    }
  }
});
var selectors3SyntaxDefinition = extendSyntaxDefinition(css2SyntaxDefinition, {
  namespace: {
    wildcard: true
  },
  combinators: ["~"],
  attributes: {
    operators: ["^=", "$=", "*="]
  },
  pseudoElements: {
    notation: "both"
  },
  pseudoClasses: {
    definitions: {
      NoArgument: [
        "root",
        "last-child",
        "first-of-type",
        "last-of-type",
        "only-child",
        "only-of-type",
        "empty",
        "target",
        "enabled",
        "disabled",
        "checked",
        "indeterminate"
      ],
      Formula: ["nth-child", "nth-last-child", "nth-of-type", "nth-last-of-type"],
      Selector: ["not"]
    }
  }
});
var selectors4SyntaxDefinition = extendSyntaxDefinition(selectors3SyntaxDefinition, {
  combinators: ["||"],
  attributes: {
    caseSensitivityModifiers: ["i", "I", "s", "S"]
  },
  pseudoClasses: {
    definitions: {
      NoArgument: [
        "any-link",
        "local-link",
        "target-within",
        "scope",
        "current",
        "past",
        "future",
        "focus-within",
        "focus-visible",
        "read-write",
        "read-only",
        "placeholder-shown",
        "default",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "required",
        "optional",
        "blank",
        "user-invalid"
      ],
      Formula: ["nth-col", "nth-last-col"],
      String: ["dir"],
      FormulaOfSelector: ["nth-child", "nth-last-child"],
      Selector: ["current", "is", "where", "has"]
    }
  }
});
var progressiveSyntaxDefinition = extendSyntaxDefinition(selectors4SyntaxDefinition, {
  pseudoElements: {
    unknown: "accept"
  },
  pseudoClasses: {
    unknown: "accept"
  },
  attributes: {
    unknownCaseSensitivityModifiers: "accept"
  }
});
var cssSyntaxDefinitions = {
  css1: css1SyntaxDefinition,
  css2: css2SyntaxDefinition,
  css3: selectors3SyntaxDefinition,
  "selectors-3": selectors3SyntaxDefinition,
  "selectors-4": selectors4SyntaxDefinition,
  latest: selectors4SyntaxDefinition,
  progressive: progressiveSyntaxDefinition
};

// node_modules/css-selector-parser/dist/mjs/utils.js
function isIdentStart(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "-" || c === "_" || c === "\\" || c >= " ";
}
function isIdent(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "-" || c === "_" || c >= " ";
}
function isHex(c) {
  return c >= "a" && c <= "f" || c >= "A" && c <= "F" || c >= "0" && c <= "9";
}
var whitespaceChars = {
  " ": true,
  "	": true,
  "\n": true,
  "\r": true,
  "\f": true
};
var quoteChars = {
  '"': true,
  "'": true
};
var digitsChars = {
  0: true,
  1: true,
  2: true,
  3: true,
  4: true,
  5: true,
  6: true,
  7: true,
  8: true,
  9: true
};
var maxHexLength = 6;

// node_modules/css-selector-parser/dist/mjs/parser.js
var errorPrefix = "css-selector-parser parse error: ";
function createParser(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.syntax, syntax = _a === void 0 ? "latest" : _a, substitutes = options.substitutes, _b = options.strict, strict = _b === void 0 ? true : _b;
  var syntaxDefinition = typeof syntax === "object" ? syntax : cssSyntaxDefinitions[syntax];
  if (syntaxDefinition.baseSyntax) {
    syntaxDefinition = extendSyntaxDefinition(cssSyntaxDefinitions[syntaxDefinition.baseSyntax], syntaxDefinition);
  }
  var _c = syntaxDefinition.tag ? [true, Boolean(getXmlOptions(syntaxDefinition.tag).wildcard)] : [false, false], tagNameEnabled = _c[0], tagNameWildcardEnabled = _c[1];
  var idEnabled = Boolean(syntaxDefinition.ids);
  var classNamesEnabled = Boolean(syntaxDefinition.classNames);
  var namespaceEnabled = Boolean(syntaxDefinition.namespace);
  var namespaceWildcardEnabled = syntaxDefinition.namespace && (syntaxDefinition.namespace === true || syntaxDefinition.namespace.wildcard === true);
  if (namespaceEnabled && !tagNameEnabled) {
    throw new Error("".concat(errorPrefix, "Namespaces cannot be enabled while tags are disabled."));
  }
  var substitutesEnabled = Boolean(substitutes);
  var combinatorsIndex = syntaxDefinition.combinators ? createMulticharIndex(syntaxDefinition.combinators) : emptyMulticharIndex;
  var _d = syntaxDefinition.attributes ? [
    true,
    syntaxDefinition.attributes.operators ? createMulticharIndex(syntaxDefinition.attributes.operators) : emptyMulticharIndex,
    syntaxDefinition.attributes.caseSensitivityModifiers ? createRegularIndex(syntaxDefinition.attributes.caseSensitivityModifiers) : emptyRegularIndex,
    syntaxDefinition.attributes.unknownCaseSensitivityModifiers === "accept"
  ] : [false, emptyMulticharIndex, emptyRegularIndex, false], attributesEnabled = _d[0], attributesOperatorsIndex = _d[1], attributesCaseSensitivityModifiers = _d[2], attributesAcceptUnknownCaseSensitivityModifiers = _d[3];
  var attributesCaseSensitivityModifiersEnabled = attributesAcceptUnknownCaseSensitivityModifiers || Object.keys(attributesCaseSensitivityModifiers).length > 0;
  var _e = syntaxDefinition.pseudoClasses ? [
    true,
    syntaxDefinition.pseudoClasses.definitions ? calculatePseudoSignatures(syntaxDefinition.pseudoClasses.definitions) : emptyPseudoSignatures,
    syntaxDefinition.pseudoClasses.unknown === "accept"
  ] : [false, emptyPseudoSignatures, false], pseudoClassesEnabled = _e[0], pseudoClassesDefinitions = _e[1], pseudoClassesAcceptUnknown = _e[2];
  var _f = syntaxDefinition.pseudoElements ? [
    true,
    syntaxDefinition.pseudoElements.notation === "singleColon" || syntaxDefinition.pseudoElements.notation === "both",
    !syntaxDefinition.pseudoElements.notation || syntaxDefinition.pseudoElements.notation === "doubleColon" || syntaxDefinition.pseudoElements.notation === "both",
    syntaxDefinition.pseudoElements.definitions ? calculatePseudoSignatures(Array.isArray(syntaxDefinition.pseudoElements.definitions) ? { NoArgument: syntaxDefinition.pseudoElements.definitions } : syntaxDefinition.pseudoElements.definitions) : emptyPseudoSignatures,
    syntaxDefinition.pseudoElements.unknown === "accept"
  ] : [false, false, false, emptyPseudoSignatures, false], pseudoElementsEnabled = _f[0], pseudoElementsSingleColonNotationEnabled = _f[1], pseudoElementsDoubleColonNotationEnabled = _f[2], pseudoElementsDefinitions = _f[3], pseudoElementsAcceptUnknown = _f[4];
  var str = "";
  var l = str.length;
  var pos = 0;
  var chr = "";
  var is2 = function(comparison) {
    return chr === comparison;
  };
  var isTagStart = function() {
    return is2("*") || isIdentStart(chr);
  };
  var rewind = function(newPos) {
    pos = newPos;
    chr = str.charAt(pos);
  };
  var next = function() {
    pos++;
    chr = str.charAt(pos);
  };
  var readAndNext = function() {
    var current = chr;
    pos++;
    chr = str.charAt(pos);
    return current;
  };
  function fail(errorMessage) {
    var position = Math.min(l - 1, pos);
    var error = new Error("".concat(errorPrefix).concat(errorMessage, " Pos: ").concat(position, "."));
    error.position = position;
    error.name = "ParserError";
    throw error;
  }
  function assert(condition, errorMessage) {
    if (!condition) {
      return fail(errorMessage);
    }
  }
  var assertNonEof = function() {
    assert(pos < l, "Unexpected end of input.");
  };
  var isEof = function() {
    return pos >= l;
  };
  var pass = function(character) {
    assert(pos < l, 'Expected "'.concat(character, '" but end of input reached.'));
    assert(chr === character, 'Expected "'.concat(character, '" but "').concat(chr, '" found.'));
    pos++;
    chr = str.charAt(pos);
  };
  function matchMulticharIndex(index) {
    var match = matchMulticharIndexPos(index, pos);
    if (match) {
      pos += match.length;
      chr = str.charAt(pos);
      return match;
    }
  }
  function matchMulticharIndexPos(index, subPos) {
    var char = str.charAt(subPos);
    var charIndex = index[char];
    if (charIndex) {
      var subMatch = matchMulticharIndexPos(charIndex.chars, subPos + 1);
      if (subMatch) {
        return subMatch;
      }
      if (charIndex.self) {
        return charIndex.self;
      }
    }
  }
  function parseHex() {
    var hex = readAndNext();
    var count2 = 1;
    while (isHex(chr) && count2 < maxHexLength) {
      hex += readAndNext();
      count2++;
    }
    skipSingleWhitespace();
    return String.fromCharCode(parseInt(hex, 16));
  }
  function parseString(quote) {
    var result = "";
    pass(quote);
    while (pos < l) {
      if (is2(quote)) {
        next();
        return result;
      } else if (is2("\\")) {
        next();
        if (is2(quote)) {
          result += quote;
          next();
        } else if (chr === "\n" || chr === "\f") {
          next();
        } else if (chr === "\r") {
          next();
          if (is2("\n")) {
            next();
          }
        } else if (isHex(chr)) {
          result += parseHex();
        } else {
          result += chr;
          next();
        }
      } else {
        result += chr;
        next();
      }
    }
    return result;
  }
  function parseIdentifier() {
    if (!isIdentStart(chr)) {
      return null;
    }
    var result = "";
    while (is2("-")) {
      result += chr;
      next();
    }
    if (result === "-" && !isIdent(chr) && !is2("\\")) {
      fail("Identifiers cannot consist of a single hyphen.");
    }
    if (strict && result.length >= 2) {
      fail("Identifiers cannot start with two hyphens with strict mode on.");
    }
    if (digitsChars[chr]) {
      fail("Identifiers cannot start with hyphens followed by digits.");
    }
    while (pos < l) {
      if (isIdent(chr)) {
        result += readAndNext();
      } else if (is2("\\")) {
        next();
        assertNonEof();
        if (isHex(chr)) {
          result += parseHex();
        } else {
          result += readAndNext();
        }
      } else {
        break;
      }
    }
    return result;
  }
  function parsePseudoClassString() {
    var result = "";
    while (pos < l) {
      if (is2(")")) {
        break;
      } else if (is2("\\")) {
        next();
        if (isEof() && !strict) {
          return (result + "\\").trim();
        }
        assertNonEof();
        if (isHex(chr)) {
          result += parseHex();
        } else {
          result += readAndNext();
        }
      } else {
        result += readAndNext();
      }
    }
    return result.trim();
  }
  function skipSingleWhitespace() {
    if (chr === " " || chr === "	" || chr === "\f" || chr === "\n") {
      next();
      return;
    }
    if (chr === "\r") {
      next();
    }
    if (chr === "\n") {
      next();
    }
  }
  function skipWhitespace() {
    while (whitespaceChars[chr]) {
      next();
    }
  }
  function parseSelector(relative) {
    if (relative === void 0) {
      relative = false;
    }
    skipWhitespace();
    var rules = [parseRule(relative)];
    while (is2(",")) {
      next();
      skipWhitespace();
      rules.push(parseRule(relative));
    }
    return {
      type: "Selector",
      rules
    };
  }
  function parseAttribute() {
    pass("[");
    skipWhitespace();
    var attr;
    if (is2("|")) {
      assert(namespaceEnabled, "Namespaces are not enabled.");
      next();
      var name_1 = parseIdentifier();
      assert(name_1, "Expected attribute name.");
      attr = {
        type: "Attribute",
        name: name_1,
        namespace: { type: "NoNamespace" }
      };
    } else if (is2("*")) {
      assert(namespaceEnabled, "Namespaces are not enabled.");
      assert(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
      next();
      pass("|");
      var name_2 = parseIdentifier();
      assert(name_2, "Expected attribute name.");
      attr = {
        type: "Attribute",
        name: name_2,
        namespace: { type: "WildcardNamespace" }
      };
    } else {
      var identifier = parseIdentifier();
      assert(identifier, "Expected attribute name.");
      attr = {
        type: "Attribute",
        name: identifier
      };
      if (is2("|")) {
        var savedPos = pos;
        next();
        if (isIdentStart(chr)) {
          assert(namespaceEnabled, "Namespaces are not enabled.");
          var name_3 = parseIdentifier();
          assert(name_3, "Expected attribute name.");
          attr = {
            type: "Attribute",
            name: name_3,
            namespace: { type: "NamespaceName", name: identifier }
          };
        } else {
          rewind(savedPos);
        }
      }
    }
    assert(attr.name, "Expected attribute name.");
    skipWhitespace();
    if (isEof() && !strict) {
      return attr;
    }
    if (is2("]")) {
      next();
    } else {
      attr.operator = matchMulticharIndex(attributesOperatorsIndex);
      assert(attr.operator, "Expected a valid attribute selector operator.");
      skipWhitespace();
      assertNonEof();
      if (quoteChars[chr]) {
        attr.value = {
          type: "String",
          value: parseString(chr)
        };
      } else if (substitutesEnabled && is2("$")) {
        next();
        var name_4 = parseIdentifier();
        assert(name_4, "Expected substitute name.");
        attr.value = {
          type: "Substitution",
          name: name_4
        };
      } else {
        var value = parseIdentifier();
        assert(value, "Expected attribute value.");
        attr.value = {
          type: "String",
          value
        };
      }
      skipWhitespace();
      if (isEof() && !strict) {
        return attr;
      }
      if (!is2("]")) {
        var caseSensitivityModifier = parseIdentifier();
        assert(caseSensitivityModifier, "Expected end of attribute selector.");
        attr.caseSensitivityModifier = caseSensitivityModifier;
        assert(attributesCaseSensitivityModifiersEnabled, "Attribute case sensitivity modifiers are not enabled.");
        assert(attributesAcceptUnknownCaseSensitivityModifiers || attributesCaseSensitivityModifiers[attr.caseSensitivityModifier], "Unknown attribute case sensitivity modifier.");
        skipWhitespace();
        if (isEof() && !strict) {
          return attr;
        }
      }
      pass("]");
    }
    return attr;
  }
  function parseNumber() {
    var result = "";
    while (digitsChars[chr]) {
      result += readAndNext();
    }
    assert(result !== "", "Formula parse error.");
    return parseInt(result);
  }
  var isNumberStart = function() {
    return is2("-") || is2("+") || digitsChars[chr];
  };
  function parseFormula() {
    if (is2("e") || is2("o")) {
      var ident = parseIdentifier();
      if (ident === "even") {
        skipWhitespace();
        return [2, 0];
      }
      if (ident === "odd") {
        skipWhitespace();
        return [2, 1];
      }
    }
    var firstNumber = null;
    var firstNumberMultiplier = 1;
    if (is2("-")) {
      next();
      firstNumberMultiplier = -1;
    }
    if (isNumberStart()) {
      if (is2("+")) {
        next();
      }
      firstNumber = parseNumber();
      if (!is2("\\") && !is2("n")) {
        return [0, firstNumber * firstNumberMultiplier];
      }
    }
    if (firstNumber === null) {
      firstNumber = 1;
    }
    firstNumber *= firstNumberMultiplier;
    var identifier;
    if (is2("\\")) {
      next();
      if (isHex(chr)) {
        identifier = parseHex();
      } else {
        identifier = readAndNext();
      }
    } else {
      identifier = readAndNext();
    }
    assert(identifier === "n", 'Formula parse error: expected "n".');
    skipWhitespace();
    if (is2("+") || is2("-")) {
      var sign = is2("+") ? 1 : -1;
      next();
      skipWhitespace();
      return [firstNumber, sign * parseNumber()];
    } else {
      return [firstNumber, 0];
    }
  }
  function parsePseudoArgument(pseudoName, type, signature) {
    var argument;
    if (is2("(")) {
      next();
      skipWhitespace();
      if (substitutesEnabled && is2("$")) {
        next();
        var name_5 = parseIdentifier();
        assert(name_5, "Expected substitute name.");
        argument = {
          type: "Substitution",
          name: name_5
        };
      } else if (signature.type === "String") {
        argument = {
          type: "String",
          value: parsePseudoClassString()
        };
        assert(argument.value, "Expected ".concat(type, " argument value."));
      } else if (signature.type === "Selector") {
        argument = parseSelector(true);
      } else if (signature.type === "Formula") {
        var _a2 = parseFormula(), a = _a2[0], b = _a2[1];
        argument = {
          type: "Formula",
          a,
          b
        };
        if (signature.ofSelector) {
          skipWhitespace();
          if (is2("o") || is2("\\")) {
            var ident = parseIdentifier();
            assert(ident === "of", "Formula of selector parse error.");
            skipWhitespace();
            argument = {
              type: "FormulaOfSelector",
              a,
              b,
              selector: parseRule()
            };
          }
        }
      } else {
        return fail("Invalid ".concat(type, " signature."));
      }
      skipWhitespace();
      if (isEof() && !strict) {
        return argument;
      }
      pass(")");
    } else {
      assert(signature.optional, "Argument is required for ".concat(type, ' "').concat(pseudoName, '".'));
    }
    return argument;
  }
  function parseTagName() {
    if (is2("*")) {
      assert(tagNameWildcardEnabled, "Wildcard tag name is not enabled.");
      next();
      return { type: "WildcardTag" };
    } else if (isIdentStart(chr)) {
      assert(tagNameEnabled, "Tag names are not enabled.");
      var name_6 = parseIdentifier();
      assert(name_6, "Expected tag name.");
      return {
        type: "TagName",
        name: name_6
      };
    } else {
      return fail("Expected tag name.");
    }
  }
  function parseTagNameWithNamespace() {
    if (is2("*")) {
      var savedPos = pos;
      next();
      if (!is2("|")) {
        rewind(savedPos);
        return parseTagName();
      }
      next();
      if (!isTagStart()) {
        rewind(savedPos);
        return parseTagName();
      }
      assert(namespaceEnabled, "Namespaces are not enabled.");
      assert(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
      var tagName = parseTagName();
      tagName.namespace = { type: "WildcardNamespace" };
      return tagName;
    } else if (is2("|")) {
      assert(namespaceEnabled, "Namespaces are not enabled.");
      next();
      var tagName = parseTagName();
      tagName.namespace = { type: "NoNamespace" };
      return tagName;
    } else if (isIdentStart(chr)) {
      var identifier = parseIdentifier();
      assert(identifier, "Expected tag name.");
      if (!is2("|")) {
        assert(tagNameEnabled, "Tag names are not enabled.");
        return {
          type: "TagName",
          name: identifier
        };
      }
      var savedPos = pos;
      next();
      if (!isTagStart()) {
        rewind(savedPos);
        return {
          type: "TagName",
          name: identifier
        };
      }
      assert(namespaceEnabled, "Namespaces are not enabled.");
      var tagName = parseTagName();
      tagName.namespace = { type: "NamespaceName", name: identifier };
      return tagName;
    } else {
      return fail("Expected tag name.");
    }
  }
  function parseRule(relative) {
    var _a2, _b2;
    if (relative === void 0) {
      relative = false;
    }
    var rule = { type: "Rule", items: [] };
    if (relative) {
      var combinator = matchMulticharIndex(combinatorsIndex);
      if (combinator) {
        rule.combinator = combinator;
        skipWhitespace();
      }
    }
    while (pos < l) {
      if (isTagStart()) {
        assert(rule.items.length === 0, "Unexpected tag/namespace start.");
        rule.items.push(parseTagNameWithNamespace());
      } else if (is2("|")) {
        var savedPos = pos;
        next();
        if (isTagStart()) {
          assert(rule.items.length === 0, "Unexpected tag/namespace start.");
          rewind(savedPos);
          rule.items.push(parseTagNameWithNamespace());
        } else {
          rewind(savedPos);
          break;
        }
      } else if (is2(".")) {
        assert(classNamesEnabled, "Class names are not enabled.");
        next();
        var className2 = parseIdentifier();
        assert(className2, "Expected class name.");
        rule.items.push({ type: "ClassName", name: className2 });
      } else if (is2("#")) {
        assert(idEnabled, "IDs are not enabled.");
        next();
        var idName = parseIdentifier();
        assert(idName, "Expected ID name.");
        rule.items.push({ type: "Id", name: idName });
      } else if (is2("[")) {
        assert(attributesEnabled, "Attributes are not enabled.");
        rule.items.push(parseAttribute());
      } else if (is2(":")) {
        var isDoubleColon = false;
        var isPseudoElement = false;
        next();
        if (is2(":")) {
          assert(pseudoElementsEnabled, "Pseudo elements are not enabled.");
          assert(pseudoElementsDoubleColonNotationEnabled, "Pseudo elements double colon notation is not enabled.");
          isDoubleColon = true;
          next();
        }
        var pseudoName = parseIdentifier();
        assert(isDoubleColon || pseudoName, "Expected pseudo-class name.");
        assert(!isDoubleColon || pseudoName, "Expected pseudo-element name.");
        assert(pseudoName, "Expected pseudo-class name.");
        assert(!isDoubleColon || pseudoElementsAcceptUnknown || Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName), 'Unknown pseudo-element "'.concat(pseudoName, '".'));
        isPseudoElement = pseudoElementsEnabled && (isDoubleColon || !isDoubleColon && pseudoElementsSingleColonNotationEnabled && Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName));
        if (isPseudoElement) {
          var signature = (_a2 = pseudoElementsDefinitions[pseudoName]) !== null && _a2 !== void 0 ? _a2 : pseudoElementsAcceptUnknown && defaultPseudoSignature;
          var pseudoElement = {
            type: "PseudoElement",
            name: pseudoName
          };
          var argument = parsePseudoArgument(pseudoName, "pseudo-element", signature);
          if (argument) {
            assert(argument.type !== "Formula" && argument.type !== "FormulaOfSelector", "Pseudo-elements cannot have formula argument.");
            pseudoElement.argument = argument;
          }
          rule.items.push(pseudoElement);
        } else {
          assert(pseudoClassesEnabled, "Pseudo-classes are not enabled.");
          var signature = (_b2 = pseudoClassesDefinitions[pseudoName]) !== null && _b2 !== void 0 ? _b2 : pseudoClassesAcceptUnknown && defaultPseudoSignature;
          assert(signature, 'Unknown pseudo-class: "'.concat(pseudoName, '".'));
          var argument = parsePseudoArgument(pseudoName, "pseudo-class", signature);
          var pseudoClass = {
            type: "PseudoClass",
            name: pseudoName
          };
          if (argument) {
            pseudoClass.argument = argument;
          }
          rule.items.push(pseudoClass);
        }
      } else {
        break;
      }
    }
    if (rule.items.length === 0) {
      if (isEof()) {
        return fail("Expected rule but end of input reached.");
      } else {
        return fail('Expected rule but "'.concat(chr, '" found.'));
      }
    }
    skipWhitespace();
    if (!isEof() && !is2(",") && !is2(")")) {
      var combinator = matchMulticharIndex(combinatorsIndex);
      skipWhitespace();
      rule.nestedRule = parseRule();
      rule.nestedRule.combinator = combinator;
    }
    return rule;
  }
  return function(input) {
    if (typeof input !== "string") {
      throw new Error("".concat(errorPrefix, "Expected string input."));
    }
    str = input;
    l = str.length;
    pos = 0;
    chr = str.charAt(0);
    return parseSelector();
  };
}

// node_modules/css-selector-parser/dist/mjs/ast.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function astMethods(type) {
  return function(generatorName, checkerName) {
    var _a;
    return _a = {}, _a[generatorName] = function(props) {
      return __assign2({ type }, props);
    }, _a[checkerName] = function(entity) {
      return typeof entity === "object" && entity !== null && entity.type === type;
    }, _a;
  };
}
var ast = __assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2(__assign2({}, astMethods("Selector")("selector", "isSelector")), astMethods("Rule")("rule", "isRule")), astMethods("TagName")("tagName", "isTagName")), astMethods("Id")("id", "isId")), astMethods("ClassName")("className", "isClassName")), astMethods("WildcardTag")("wildcardTag", "isWildcardTag")), astMethods("NamespaceName")("namespaceName", "isNamespaceName")), astMethods("WildcardNamespace")("wildcardNamespace", "isWildcardNamespace")), astMethods("NoNamespace")("noNamespace", "isNoNamespace")), astMethods("Attribute")("attribute", "isAttribute")), astMethods("PseudoClass")("pseudoClass", "isPseudoClass")), astMethods("PseudoElement")("pseudoElement", "isPseudoElement")), astMethods("String")("string", "isString")), astMethods("Formula")("formula", "isFormula")), astMethods("FormulaOfSelector")("formulaOfSelector", "isFormulaOfSelector")), astMethods("Substitution")("substitution", "isSubstitution"));

// node_modules/hast-util-select/lib/parse.js
var cssSelectorParse = createParser({ syntax: "selectors-4" });
function parse3(selector) {
  if (typeof selector !== "string") {
    throw new TypeError("Expected `string` as selector, not `" + selector + "`");
  }
  return cssSelectorParse(selector);
}

// node_modules/direction/index.js
var rtlRange = "֑-߿יִ-﷽ﹰ-ﻼ";
var ltrRange = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
var rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
var ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");
function direction(value) {
  const source = String(value || "");
  return rtl.test(source) ? "rtl" : ltr.test(source) ? "ltr" : "neutral";
}

// node_modules/hast-util-select/lib/enter-state.js
function enterState(state, node) {
  const schema = state.schema;
  const language = state.language;
  const currentDirection = state.direction;
  const editableOrEditingHost = state.editableOrEditingHost;
  let dirInferred;
  if (node.type === "element") {
    const lang2 = node.properties.xmlLang || node.properties.lang;
    const type = node.properties.type || "text";
    const dir2 = dirProperty(node);
    if (lang2 !== null && lang2 !== void 0) {
      state.language = String(lang2);
    }
    if (schema && schema.space === "html") {
      if (node.properties.contentEditable === "true") {
        state.editableOrEditingHost = true;
      }
      if (node.tagName === "svg") {
        state.schema = svg;
      }
      if (dir2 === "rtl") {
        dirInferred = dir2;
      } else if (
        // Explicit `[dir=ltr]`.
        dir2 === "ltr" || // HTML with an invalid or no `[dir]`.
        dir2 !== "auto" && node.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
        dir2 !== "auto" && node.tagName === "input" && type === "tel"
      ) {
        dirInferred = "ltr";
      } else if (dir2 === "auto" || node.tagName === "bdi") {
        if (node.tagName === "textarea") {
          dirInferred = dirBidi(toString(node));
        } else if (node.tagName === "input" && (type === "email" || type === "search" || type === "tel" || type === "text")) {
          dirInferred = node.properties.value ? dirBidi(String(node.properties.value)) : "ltr";
        } else {
          visit(node, inferDirectionality);
        }
      }
      if (dirInferred) {
        state.direction = dirInferred;
      }
    } else if (state.editableOrEditingHost) {
      state.editableOrEditingHost = false;
    }
  }
  return reset;
  function reset() {
    state.schema = schema;
    state.language = language;
    state.direction = currentDirection;
    state.editableOrEditingHost = editableOrEditingHost;
  }
  function inferDirectionality(child) {
    if (child.type === "text") {
      dirInferred = dirBidi(child.value);
      return dirInferred ? EXIT : void 0;
    }
    if (child !== node && child.type === "element" && (child.tagName === "bdi" || child.tagName === "script" || child.tagName === "style" || child.tagName === "textare" || dirProperty(child))) {
      return SKIP;
    }
  }
}
function dirBidi(value) {
  const result = direction(value);
  return result === "neutral" ? void 0 : result;
}
function dirProperty(node) {
  const value = node.type === "element" && typeof node.properties.dir === "string" ? node.properties.dir.toLowerCase() : void 0;
  return value === "auto" || value === "ltr" || value === "rtl" ? value : void 0;
}

// node_modules/hast-util-select/lib/attribute.js
function attribute(query, element, schema) {
  const info = find(schema, query.name);
  const propertyValue = element.properties[info.property];
  let value = normalizeValue(propertyValue, info);
  if (!query.value) {
    return value !== void 0;
  }
  ok(query.value.type === "String", "expected plain string");
  let key = query.value.value;
  if (query.caseSensitivityModifier === "i") {
    key = key.toLowerCase();
    if (value) {
      value = value.toLowerCase();
    }
  }
  if (value !== void 0) {
    switch (query.operator) {
      case "=": {
        return key === value;
      }
      case "$=": {
        return key === value.slice(-key.length);
      }
      case "*=": {
        return value.includes(key);
      }
      case "^=": {
        return key === value.slice(0, key.length);
      }
      case "|=": {
        return key === value || key === value.slice(0, key.length) && value.charAt(key.length) === "-";
      }
      case "~=": {
        return (
          // For all other values (including comma-separated lists), return whether this
          // is an exact match.
          key === value || // If this is a space-separated list, and the query is contained in it, return
          // true.
          parse2(value).includes(key)
        );
      }
    }
  }
  return false;
}
function normalizeValue(value, info) {
  if (value === null || value === void 0) {
  } else if (typeof value === "boolean") {
    if (value) {
      return info.attribute;
    }
  } else if (Array.isArray(value)) {
    if (value.length > 0) {
      return (info.commaSeparated ? stringify : stringify2)(value);
    }
  } else {
    return String(value);
  }
}

// node_modules/hast-util-select/lib/class-name.js
var emptyClassNames = [];
function className(query, element) {
  const value = (
    /** @type {Readonly<Array<string>>} */
    element.properties.className || emptyClassNames
  );
  return value.includes(query.name);
}

// node_modules/hast-util-select/lib/id.js
function id(query, element) {
  return element.properties.id === query.name;
}

// node_modules/hast-util-select/lib/name.js
function name(query, element) {
  return query.name === element.tagName;
}

// node_modules/bcp-47-match/index.js
function factory(check, filter) {
  return function(tags, ranges) {
    let left = cast(tags, "tag");
    const right = cast(
      ranges === null || ranges === void 0 ? "*" : ranges,
      "range"
    );
    const matches2 = [];
    let rightIndex = -1;
    while (++rightIndex < right.length) {
      const range = right[rightIndex].toLowerCase();
      if (!filter && range === "*")
        continue;
      let leftIndex = -1;
      const next = [];
      while (++leftIndex < left.length) {
        if (check(left[leftIndex].toLowerCase(), range)) {
          if (!filter) {
            return (
              /** @type {IsFilter extends true ? Tags : Tag|undefined} */
              left[leftIndex]
            );
          }
          matches2.push(left[leftIndex]);
        } else {
          next.push(left[leftIndex]);
        }
      }
      left = next;
    }
    return (
      /** @type {IsFilter extends true ? Tags : Tag|undefined} */
      filter ? matches2 : void 0
    );
  };
}
var basicFilter = factory(function(tag, range) {
  return range === "*" || tag === range || tag.includes(range + "-");
}, true);
var extendedFilter = factory(function(tag, range) {
  const left = tag.split("-");
  const right = range.split("-");
  let leftIndex = 0;
  let rightIndex = 0;
  if (right[rightIndex] !== "*" && left[leftIndex] !== right[rightIndex]) {
    return false;
  }
  leftIndex++;
  rightIndex++;
  while (rightIndex < right.length) {
    if (right[rightIndex] === "*") {
      rightIndex++;
      continue;
    }
    if (!left[leftIndex])
      return false;
    if (left[leftIndex] === right[rightIndex]) {
      leftIndex++;
      rightIndex++;
      continue;
    }
    if (left[leftIndex].length === 1)
      return false;
    leftIndex++;
  }
  return true;
}, true);
var lookup = factory(function(tag, range) {
  let right = range;
  while (true) {
    if (right === "*" || tag === right)
      return true;
    let index = right.lastIndexOf("-");
    if (index < 0)
      return false;
    if (right.charAt(index - 2) === "-")
      index -= 2;
    right = right.slice(0, index);
  }
}, false);
function cast(values, name2) {
  const value = values && typeof values === "string" ? [values] : values;
  if (!value || typeof value !== "object" || !("length" in value)) {
    throw new Error(
      "Invalid " + name2 + " `" + value + "`, expected non-empty string"
    );
  }
  return value;
}

// node_modules/hast-util-has-property/lib/index.js
var own = {}.hasOwnProperty;
function hasProperty(node, name2) {
  const value = node.type === "element" && own.call(node.properties, name2) && node.properties[name2];
  return value !== null && value !== void 0 && value !== false;
}

// node_modules/nth-check/lib/esm/parse.js
var whitespace2 = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
function parse4(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace2.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}

// node_modules/nth-check/lib/esm/compile.js
var import_boolbase = __toESM(require_boolbase(), 1);
function compile(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return import_boolbase.default.falseFunc;
  if (a === -1)
    return (index) => index <= b;
  if (a === 0)
    return (index) => index === b;
  if (a === 1)
    return b < 0 ? import_boolbase.default.trueFunc : (index) => index >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index) => index >= b && index % absA === bMod : (index) => index <= b && index % absA === bMod;
}

// node_modules/nth-check/lib/esm/index.js
function nthCheck(formula) {
  return compile(parse4(formula));
}

// node_modules/hast-util-select/lib/pseudo.js
var nthCheck2 = nthCheck.default || nthCheck;
var pseudo = zwitch("name", {
  handlers: {
    "any-link": anyLink,
    blank,
    checked,
    dir,
    disabled,
    empty,
    enabled,
    "first-child": firstChild,
    "first-of-type": firstOfType,
    has,
    is,
    lang,
    "last-child": lastChild,
    "last-of-type": lastOfType,
    not,
    "nth-child": nthChild,
    "nth-last-child": nthLastChild,
    "nth-last-of-type": nthLastOfType,
    "nth-of-type": nthOfType,
    "only-child": onlyChild,
    "only-of-type": onlyOfType,
    optional,
    "read-only": readOnly,
    "read-write": readWrite,
    required,
    root,
    scope
  },
  invalid: invalidPseudo,
  unknown: unknownPseudo
});
function anyLink(_, element) {
  return (element.tagName === "a" || element.tagName === "area" || element.tagName === "link") && hasProperty(element, "href");
}
function assertDeep(state, query) {
  if (state.shallow) {
    throw new Error("Cannot use `:" + query.name + "` without parent");
  }
}
function blank(_, element) {
  return !someChildren(element, check);
  function check(child) {
    return child.type === "element" || child.type === "text" && !whitespace(child);
  }
}
function checked(_, element) {
  if (element.tagName === "input" || element.tagName === "menuitem") {
    return Boolean(
      (element.properties.type === "checkbox" || element.properties.type === "radio") && hasProperty(element, "checked")
    );
  }
  if (element.tagName === "option") {
    return hasProperty(element, "selected");
  }
  return false;
}
function dir(query, _1, _2, _3, state) {
  ok(query.argument, "expected `argument`");
  ok(query.argument.type === "String", "expected plain text");
  return state.direction === query.argument.value;
}
function disabled(_, element) {
  return (element.tagName === "button" || element.tagName === "input" || element.tagName === "select" || element.tagName === "textarea" || element.tagName === "optgroup" || element.tagName === "option" || element.tagName === "menuitem" || element.tagName === "fieldset") && hasProperty(element, "disabled");
}
function empty(_, element) {
  return !someChildren(element, check);
  function check(child) {
    return child.type === "element" || child.type === "text";
  }
}
function enabled(query, element) {
  return !disabled(query, element);
}
function firstChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.elementIndex === 0;
}
function firstOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeIndex === 0;
}
function getCachedNthCheck(query) {
  let fn = query._cachedFn;
  if (!fn) {
    const value = query.argument;
    ok(value, "expected `argument`");
    if (value.type !== "Formula") {
      throw new Error(
        "Expected `nth` formula, such as `even` or `2n+1` (`of` is not yet supported)"
      );
    }
    fn = nthCheck2(value.a + "n+" + value.b);
    query._cachedFn = fn;
  }
  return fn;
}
function has(query, element, _1, _2, state) {
  ok(query.argument, "expected `argument`");
  ok(query.argument.type === "Selector", "expected selector");
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // One result is enough.
    one: true,
    results: [],
    rootQuery: query.argument,
    scopeElements: [element],
    // Do walk deep.
    shallow: false
  };
  walk(childState, { type: "root", children: element.children });
  return childState.results.length > 0;
}
function invalidPseudo() {
  unreachable("Invalid pseudo-selector");
}
function is(query, element, _1, _2, state) {
  ok(query.argument, "expected `argument`");
  ok(query.argument.type === "Selector", "expected selector");
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // One result is enough.
    one: true,
    results: [],
    rootQuery: query.argument,
    scopeElements: [element],
    // Do walk deep.
    shallow: false
  };
  walk(childState, element);
  return childState.results[0] === element;
}
function lang(query, _1, _2, _3, state) {
  ok(query.argument, "expected `argument`");
  ok(query.argument.type === "String", "expected string");
  return state.language !== "" && state.language !== void 0 && extendedFilter(state.language, parse(query.argument.value)).length > 0;
}
function lastChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return Boolean(
    state.elementCount && state.elementIndex === state.elementCount - 1
  );
}
function lastOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return typeof state.typeIndex === "number" && typeof state.typeCount === "number" && state.typeIndex === state.typeCount - 1;
}
function not(query, element, index, parent, state) {
  return !is(query, element, index, parent, state);
}
function nthChild(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.elementIndex === "number" && fn(state.elementIndex);
}
function nthLastChild(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return Boolean(
    typeof state.elementCount === "number" && typeof state.elementIndex === "number" && fn(state.elementCount - state.elementIndex - 1)
  );
}
function nthLastOfType(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.typeCount === "number" && typeof state.typeIndex === "number" && fn(state.typeCount - 1 - state.typeIndex);
}
function nthOfType(query, _1, _2, _3, state) {
  const fn = getCachedNthCheck(query);
  assertDeep(state, query);
  return typeof state.typeIndex === "number" && fn(state.typeIndex);
}
function onlyChild(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.elementCount === 1;
}
function onlyOfType(query, _1, _2, _3, state) {
  assertDeep(state, query);
  return state.typeCount === 1;
}
function optional(query, element) {
  return !required(query, element);
}
function readOnly(query, element, index, parent, state) {
  return !readWrite(query, element, index, parent, state);
}
function readWrite(_, element, _1, _2, state) {
  return element.tagName === "input" || element.tagName === "textarea" ? !hasProperty(element, "readOnly") && !hasProperty(element, "disabled") : Boolean(state.editableOrEditingHost);
}
function required(_, element) {
  return (element.tagName === "input" || element.tagName === "textarea" || element.tagName === "select") && hasProperty(element, "required");
}
function root(_1, element, _2, parent, state) {
  return Boolean(
    (!parent || parent.type === "root") && state.schema && (state.schema.space === "html" || state.schema.space === "svg") && (element.tagName === "html" || element.tagName === "svg")
  );
}
function scope(_1, element, _2, _3, state) {
  return state.scopeElements.includes(element);
}
function someChildren(element, check) {
  const children = element.children;
  let index = -1;
  while (++index < children.length) {
    if (check(children[index]))
      return true;
  }
  return false;
}
function unknownPseudo(query_) {
  const query = (
    /** @type {AstPseudoClass} */
    query_
  );
  throw new Error("Unknown pseudo-selector `" + query.name + "`");
}

// node_modules/hast-util-select/lib/test.js
function test(query, element, index, parent, state) {
  for (const item of query.items) {
    if (item.type === "Attribute") {
      if (!attribute(item, element, state.schema))
        return false;
    } else if (item.type === "Id") {
      if (!id(item, element))
        return false;
    } else if (item.type === "ClassName") {
      if (!className(item, element))
        return false;
    } else if (item.type === "PseudoClass") {
      if (!pseudo(item, element, index, parent, state))
        return false;
    } else if (item.type === "PseudoElement") {
      throw new Error("Invalid selector: `::" + item.name + "`");
    } else if (item.type === "TagName") {
      if (!name(item, element))
        return false;
    } else {
    }
  }
  return true;
}

// node_modules/hast-util-select/lib/walk.js
var empty2 = [];
function walk(state, tree) {
  if (tree) {
    one(state, [], tree, void 0, void 0, tree);
  }
}
function add(nest, field, rule) {
  const list = nest[field];
  if (list) {
    list.push(rule);
  } else {
    nest[field] = [rule];
  }
}
function all(state, nest, node, tree) {
  const fromParent = combine(nest.descendant, nest.directChild);
  let fromSibling;
  let index = -1;
  const total = { count: 0, types: /* @__PURE__ */ new Map() };
  const before = { count: 0, types: /* @__PURE__ */ new Map() };
  while (++index < node.children.length) {
    count(total, node.children[index]);
  }
  index = -1;
  while (++index < node.children.length) {
    const child = node.children[index];
    const name2 = child.type === "element" ? child.tagName.toUpperCase() : void 0;
    state.elementIndex = before.count;
    state.typeIndex = name2 ? before.types.get(name2) || 0 : 0;
    state.elementCount = total.count;
    state.typeCount = name2 ? total.types.get(name2) : 0;
    if ("children" in child) {
      const forSibling = combine(fromParent, fromSibling);
      const nest2 = one(
        state,
        forSibling,
        node.children[index],
        index,
        node,
        tree
      );
      fromSibling = combine(nest2.generalSibling, nest2.adjacentSibling);
    }
    if (state.one && state.found) {
      break;
    }
    count(before, node.children[index]);
  }
}
function applySelectors(state, rules, node, index, parent) {
  const nestResult = {
    adjacentSibling: void 0,
    descendant: void 0,
    directChild: void 0,
    generalSibling: void 0
  };
  let selectorIndex = -1;
  while (++selectorIndex < rules.length) {
    const rule = rules[selectorIndex];
    if (state.one && state.found) {
      break;
    }
    if (state.shallow && rule.nestedRule) {
      throw new Error("Expected selector without nesting");
    }
    if (test(rule, node, index, parent, state)) {
      const nest = rule.nestedRule;
      if (nest) {
        const label = nest.combinator === "+" ? "adjacentSibling" : nest.combinator === "~" ? "generalSibling" : nest.combinator === ">" ? "directChild" : "descendant";
        add(nestResult, label, nest);
      } else {
        state.found = true;
        if (!state.results.includes(node)) {
          state.results.push(node);
        }
      }
    }
    if (rule.combinator === void 0) {
      add(nestResult, "descendant", rule);
    } else if (rule.combinator === "~") {
      add(nestResult, "generalSibling", rule);
    }
  }
  return nestResult;
}
function combine(left, right) {
  return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty2;
}
function count(counts, node) {
  if (node.type === "element") {
    const name2 = node.tagName.toUpperCase();
    const count2 = (counts.types.get(name2) || 0) + 1;
    counts.count++;
    counts.types.set(name2, count2);
  }
}
function one(state, currentRules, node, index, parent, tree) {
  let nestResult = {
    adjacentSibling: void 0,
    descendant: void 0,
    directChild: void 0,
    generalSibling: void 0
  };
  const exit = enterState(state, node);
  if (node.type === "element") {
    let rootRules = state.rootQuery.rules;
    if (parent && parent !== tree) {
      rootRules = state.rootQuery.rules.filter(
        (d) => d.combinator === void 0 || d.combinator === ">" && parent === tree
      );
    }
    nestResult = applySelectors(
      state,
      // Try the root rules for this element too.
      combine(currentRules, rootRules),
      node,
      index,
      parent
    );
  }
  if ("children" in node && !state.shallow && !(state.one && state.found)) {
    all(state, nestResult, node, tree);
  }
  exit();
  return nestResult;
}

// node_modules/hast-util-select/lib/index.js
function matches(selector, node, space) {
  const state = createState(selector, node, space);
  state.one = true;
  state.shallow = true;
  walk(state, node || void 0);
  return state.results.length > 0;
}
function select(selector, tree, space) {
  const state = createState(selector, tree, space);
  state.one = true;
  walk(state, tree || void 0);
  return state.results[0];
}
function selectAll(selector, tree, space) {
  const state = createState(selector, tree, space);
  walk(state, tree || void 0);
  return state.results;
}
function createState(selector, tree, space) {
  return {
    direction: "ltr",
    editableOrEditingHost: false,
    elementCount: void 0,
    elementIndex: void 0,
    found: false,
    language: void 0,
    one: false,
    // State of the query.
    results: [],
    rootQuery: parse3(selector),
    schema: space === "svg" ? svg : html,
    scopeElements: tree ? tree.type === "root" ? tree.children : [tree] : [],
    shallow: false,
    typeIndex: void 0,
    typeCount: void 0
  };
}
export {
  matches,
  select,
  selectAll
};
//# sourceMappingURL=hast-util-select.js.map
