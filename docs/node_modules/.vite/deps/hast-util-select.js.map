{
  "version": 3,
  "sources": ["../../boolbase/index.js", "../../css-selector-parser/dist/mjs/indexes.js", "../../css-selector-parser/dist/mjs/pseudo-signatures.js", "../../css-selector-parser/dist/mjs/syntax-definitions.js", "../../css-selector-parser/dist/mjs/utils.js", "../../css-selector-parser/dist/mjs/parser.js", "../../css-selector-parser/dist/mjs/ast.js", "../../hast-util-select/lib/parse.js", "../../direction/index.js", "../../hast-util-select/lib/enter-state.js", "../../hast-util-select/lib/attribute.js", "../../hast-util-select/lib/class-name.js", "../../hast-util-select/lib/id.js", "../../hast-util-select/lib/name.js", "../../bcp-47-match/index.js", "../../hast-util-has-property/lib/index.js", "../../nth-check/lib/esm/parse.ts", "../../nth-check/lib/esm/compile.ts", "../../nth-check/lib/esm/index.ts", "../../hast-util-select/lib/pseudo.js", "../../hast-util-select/lib/test.js", "../../hast-util-select/lib/walk.js", "../../hast-util-select/lib/index.js"],
  "sourcesContent": ["module.exports = {\n\ttrueFunc: function trueFunc(){\n\t\treturn true;\n\t},\n\tfalseFunc: function falseFunc(){\n\t\treturn false;\n\t}\n};", "export var emptyMulticharIndex = {};\nexport var emptyRegularIndex = {};\nfunction extendIndex(item, index) {\n    var currentIndex = index;\n    for (var pos = 0; pos < item.length; pos++) {\n        var isLast = pos === item.length - 1;\n        var char = item.charAt(pos);\n        var charIndex = currentIndex[char] || (currentIndex[char] = { chars: {} });\n        if (isLast) {\n            charIndex.self = item;\n        }\n        currentIndex = charIndex.chars;\n    }\n}\nexport function createMulticharIndex(items) {\n    if (items.length === 0) {\n        return emptyMulticharIndex;\n    }\n    var index = {};\n    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n        var item = items_1[_i];\n        extendIndex(item, index);\n    }\n    return index;\n}\nexport function createRegularIndex(items) {\n    if (items.length === 0) {\n        return emptyRegularIndex;\n    }\n    var result = {};\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n        var item = items_2[_i];\n        result[item] = true;\n    }\n    return result;\n}\n", "export var emptyPseudoSignatures = {};\nexport var defaultPseudoSignature = {\n    type: 'String',\n    optional: true\n};\nfunction calculatePseudoSignature(types) {\n    var result = {\n        type: 'NoArgument',\n        optional: false\n    };\n    function setResultType(type) {\n        if (result.type && result.type !== type && result.type !== 'NoArgument') {\n            throw new Error(\"Conflicting pseudo-class argument type: \\\"\".concat(result.type, \"\\\" vs \\\"\").concat(type, \"\\\".\"));\n        }\n        result.type = type;\n    }\n    for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n        var type = types_1[_i];\n        if (type === 'NoArgument') {\n            result.optional = true;\n        }\n        if (type === 'Formula') {\n            setResultType('Formula');\n        }\n        if (type === 'FormulaOfSelector') {\n            setResultType('Formula');\n            result.ofSelector = true;\n        }\n        if (type === 'String') {\n            setResultType('String');\n        }\n        if (type === 'Selector') {\n            setResultType('Selector');\n        }\n    }\n    return result;\n}\nexport function inverseCategories(obj) {\n    var result = {};\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var category = _a[_i];\n        var items = obj[category];\n        if (items) {\n            for (var _b = 0, _c = items; _b < _c.length; _b++) {\n                var item = _c[_b];\n                (result[item] || (result[item] = [])).push(category);\n            }\n        }\n    }\n    return result;\n}\nexport function calculatePseudoSignatures(definitions) {\n    var pseudoClassesToArgumentTypes = inverseCategories(definitions);\n    var result = {};\n    for (var _i = 0, _a = Object.keys(pseudoClassesToArgumentTypes); _i < _a.length; _i++) {\n        var pseudoClass = _a[_i];\n        var argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];\n        if (argumentTypes) {\n            result[pseudoClass] = calculatePseudoSignature(argumentTypes);\n        }\n    }\n    return result;\n}\n", "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar emptyXmlOptions = {};\nvar defaultXmlOptions = { wildcard: true };\nexport function getXmlOptions(param) {\n    if (param) {\n        if (typeof param === 'boolean') {\n            return defaultXmlOptions;\n        }\n        else {\n            return param;\n        }\n    }\n    else {\n        return emptyXmlOptions;\n    }\n}\nfunction withMigration(migration, merge) {\n    return function (base, extension) { return merge(migration(base), migration(extension)); };\n}\nfunction withNoNegative(merge) {\n    return function (base, extension) {\n        var result = merge(base, extension);\n        if (!result) {\n            throw new Error(\"Syntax definition cannot be null or undefined.\");\n        }\n        return result;\n    };\n}\nfunction withPositive(positive, merge) {\n    return function (base, extension) {\n        if (extension === true) {\n            return positive;\n        }\n        return merge(base === true ? positive : base, extension);\n    };\n}\nfunction mergeSection(values) {\n    return function (base, extension) {\n        if (!extension || !base) {\n            return extension;\n        }\n        if (typeof extension !== 'object' || extension === null) {\n            throw new Error(\"Unexpected syntax definition extension type: \".concat(extension, \".\"));\n        }\n        var result = __assign({}, base);\n        for (var _i = 0, _a = Object.entries(extension); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            var mergeSchema = values[key];\n            result[key] = mergeSchema(base[key], value);\n        }\n        return result;\n    };\n}\nfunction replaceValueIfSpecified(base, extension) {\n    if (extension !== undefined) {\n        return extension;\n    }\n    return base;\n}\nfunction concatArray(base, extension) {\n    if (!extension) {\n        return base;\n    }\n    if (!base) {\n        return extension;\n    }\n    return base.concat(extension);\n}\nfunction mergeDefinitions(base, extension) {\n    if (!extension) {\n        return base;\n    }\n    if (!base) {\n        return extension;\n    }\n    var result = __assign({}, base);\n    for (var _i = 0, _a = Object.entries(extension); _i < _a.length; _i++) {\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        if (!value) {\n            delete result[key];\n            continue;\n        }\n        var baseValue = base[key];\n        if (!baseValue) {\n            result[key] = value;\n            continue;\n        }\n        result[key] = baseValue.concat(value);\n    }\n    return result;\n}\nexport var extendSyntaxDefinition = withNoNegative(mergeSection({\n    baseSyntax: replaceValueIfSpecified,\n    tag: withPositive(defaultXmlOptions, mergeSection({\n        wildcard: replaceValueIfSpecified\n    })),\n    ids: replaceValueIfSpecified,\n    classNames: replaceValueIfSpecified,\n    namespace: withPositive(defaultXmlOptions, mergeSection({\n        wildcard: replaceValueIfSpecified\n    })),\n    combinators: concatArray,\n    attributes: mergeSection({\n        operators: concatArray,\n        caseSensitivityModifiers: concatArray,\n        unknownCaseSensitivityModifiers: replaceValueIfSpecified\n    }),\n    pseudoClasses: mergeSection({\n        unknown: replaceValueIfSpecified,\n        definitions: mergeDefinitions\n    }),\n    pseudoElements: mergeSection({\n        unknown: replaceValueIfSpecified,\n        notation: replaceValueIfSpecified,\n        definitions: withMigration(function (definitions) { return (Array.isArray(definitions) ? { NoArgument: definitions } : definitions); }, mergeDefinitions)\n    })\n}));\nvar css1SyntaxDefinition = {\n    tag: {},\n    ids: true,\n    classNames: true,\n    combinators: [],\n    pseudoElements: {\n        unknown: 'reject',\n        notation: 'singleColon',\n        definitions: ['first-letter', 'first-line']\n    },\n    pseudoClasses: {\n        unknown: 'reject',\n        definitions: {\n            NoArgument: ['link', 'visited', 'active']\n        }\n    }\n};\nvar css2SyntaxDefinition = extendSyntaxDefinition(css1SyntaxDefinition, {\n    tag: { wildcard: true },\n    combinators: ['>', '+'],\n    attributes: {\n        unknownCaseSensitivityModifiers: 'reject',\n        operators: ['=', '~=', '|=']\n    },\n    pseudoElements: {\n        definitions: ['before', 'after']\n    },\n    pseudoClasses: {\n        unknown: 'reject',\n        definitions: {\n            NoArgument: ['hover', 'focus', 'first-child'],\n            String: ['lang']\n        }\n    }\n});\nvar selectors3SyntaxDefinition = extendSyntaxDefinition(css2SyntaxDefinition, {\n    namespace: {\n        wildcard: true\n    },\n    combinators: ['~'],\n    attributes: {\n        operators: ['^=', '$=', '*=']\n    },\n    pseudoElements: {\n        notation: 'both'\n    },\n    pseudoClasses: {\n        definitions: {\n            NoArgument: [\n                'root',\n                'last-child',\n                'first-of-type',\n                'last-of-type',\n                'only-child',\n                'only-of-type',\n                'empty',\n                'target',\n                'enabled',\n                'disabled',\n                'checked',\n                'indeterminate'\n            ],\n            Formula: ['nth-child', 'nth-last-child', 'nth-of-type', 'nth-last-of-type'],\n            Selector: ['not']\n        }\n    }\n});\nvar selectors4SyntaxDefinition = extendSyntaxDefinition(selectors3SyntaxDefinition, {\n    combinators: ['||'],\n    attributes: {\n        caseSensitivityModifiers: ['i', 'I', 's', 'S']\n    },\n    pseudoClasses: {\n        definitions: {\n            NoArgument: [\n                'any-link',\n                'local-link',\n                'target-within',\n                'scope',\n                'current',\n                'past',\n                'future',\n                'focus-within',\n                'focus-visible',\n                'read-write',\n                'read-only',\n                'placeholder-shown',\n                'default',\n                'valid',\n                'invalid',\n                'in-range',\n                'out-of-range',\n                'required',\n                'optional',\n                'blank',\n                'user-invalid'\n            ],\n            Formula: ['nth-col', 'nth-last-col'],\n            String: ['dir'],\n            FormulaOfSelector: ['nth-child', 'nth-last-child'],\n            Selector: ['current', 'is', 'where', 'has']\n        }\n    }\n});\nvar progressiveSyntaxDefinition = extendSyntaxDefinition(selectors4SyntaxDefinition, {\n    pseudoElements: {\n        unknown: 'accept'\n    },\n    pseudoClasses: {\n        unknown: 'accept'\n    },\n    attributes: {\n        unknownCaseSensitivityModifiers: 'accept'\n    }\n});\nexport var cssSyntaxDefinitions = {\n    css1: css1SyntaxDefinition,\n    css2: css2SyntaxDefinition,\n    css3: selectors3SyntaxDefinition,\n    'selectors-3': selectors3SyntaxDefinition,\n    'selectors-4': selectors4SyntaxDefinition,\n    latest: selectors4SyntaxDefinition,\n    progressive: progressiveSyntaxDefinition\n};\n", "export function isIdentStart(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '-' || c === '_' || c === '\\\\' || c >= '\\u00a0';\n}\nexport function isIdent(c) {\n    return ((c >= 'a' && c <= 'z') ||\n        (c >= 'A' && c <= 'Z') ||\n        (c >= '0' && c <= '9') ||\n        c === '-' ||\n        c === '_' ||\n        c >= '\\u00a0');\n}\nexport function isHex(c) {\n    return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') || (c >= '0' && c <= '9');\n}\nexport var identEscapeChars = {\n    '!': true,\n    '\"': true,\n    '#': true,\n    $: true,\n    '%': true,\n    '&': true,\n    \"'\": true,\n    '(': true,\n    ')': true,\n    '*': true,\n    '+': true,\n    ',': true,\n    '.': true,\n    '/': true,\n    ';': true,\n    '<': true,\n    '=': true,\n    '>': true,\n    '?': true,\n    '@': true,\n    '[': true,\n    '\\\\': true,\n    ']': true,\n    '^': true,\n    '`': true,\n    '{': true,\n    '|': true,\n    '}': true,\n    '~': true\n};\nexport var stringRenderEscapeChars = {\n    '\\n': true,\n    '\\r': true,\n    '\\t': true,\n    '\\f': true,\n    '\\v': true\n};\nexport var whitespaceChars = {\n    ' ': true,\n    '\\t': true,\n    '\\n': true,\n    '\\r': true,\n    '\\f': true\n};\nexport var quoteChars = {\n    '\"': true,\n    \"'\": true\n};\nexport var digitsChars = {\n    0: true,\n    1: true,\n    2: true,\n    3: true,\n    4: true,\n    5: true,\n    6: true,\n    7: true,\n    8: true,\n    9: true\n};\nexport var maxHexLength = 6;\nexport function escapeIdentifier(s) {\n    var len = s.length;\n    var result = '';\n    var i = 0;\n    while (i < len) {\n        var chr = s.charAt(i);\n        if (identEscapeChars[chr] || (chr === '-' && i === 1 && s.charAt(0) === '-')) {\n            result += '\\\\' + chr;\n        }\n        else {\n            if (chr === '-' ||\n                chr === '_' ||\n                (chr >= 'A' && chr <= 'Z') ||\n                (chr >= 'a' && chr <= 'z') ||\n                (chr >= '0' && chr <= '9' && i !== 0 && !(i === 1 && s.charAt(0) === '-'))) {\n                result += chr;\n            }\n            else {\n                var charCode = chr.charCodeAt(0);\n                if ((charCode & 0xf800) === 0xd800) {\n                    var extraCharCode = s.charCodeAt(i++);\n                    if ((charCode & 0xfc00) !== 0xd800 || (extraCharCode & 0xfc00) !== 0xdc00) {\n                        throw Error('UCS-2(decode): illegal sequence');\n                    }\n                    charCode = ((charCode & 0x3ff) << 10) + (extraCharCode & 0x3ff) + 0x10000;\n                }\n                result += '\\\\' + charCode.toString(16) + ' ';\n            }\n        }\n        i++;\n    }\n    return result.trim();\n}\nexport function escapeString(s) {\n    var len = s.length;\n    var result = '';\n    var i = 0;\n    while (i < len) {\n        var chr = s.charAt(i);\n        if (chr === '\"') {\n            chr = '\\\\\"';\n        }\n        else if (chr === '\\\\') {\n            chr = '\\\\\\\\';\n        }\n        else if (stringRenderEscapeChars[chr]) {\n            chr = '\\\\' + chr.charCodeAt(0).toString(16) + (i === len - 1 ? '' : ' ');\n        }\n        result += chr;\n        i++;\n    }\n    return \"\\\"\".concat(result, \"\\\"\");\n}\n", "import { createMulticharIndex, createRegularIndex, emptyMulticharIndex, emptyRegularIndex } from './indexes.js';\nimport { calculatePseudoSignatures, defaultPseudoSignature, emptyPseudoSignatures } from './pseudo-signatures.js';\nimport { cssSyntaxDefinitions, extendSyntaxDefinition, getXmlOptions } from './syntax-definitions.js';\nimport { digitsChars, isHex, isIdent, isIdentStart, maxHexLength, quoteChars, whitespaceChars } from './utils.js';\nvar errorPrefix = \"css-selector-parser parse error: \";\n/**\n * Creates a parse function to be used later to parse CSS selectors.\n */\nexport function createParser(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.syntax, syntax = _a === void 0 ? 'latest' : _a, substitutes = options.substitutes, _b = options.strict, strict = _b === void 0 ? true : _b;\n    var syntaxDefinition = typeof syntax === 'object' ? syntax : cssSyntaxDefinitions[syntax];\n    if (syntaxDefinition.baseSyntax) {\n        syntaxDefinition = extendSyntaxDefinition(cssSyntaxDefinitions[syntaxDefinition.baseSyntax], syntaxDefinition);\n    }\n    var _c = syntaxDefinition.tag\n        ? [true, Boolean(getXmlOptions(syntaxDefinition.tag).wildcard)]\n        : [false, false], tagNameEnabled = _c[0], tagNameWildcardEnabled = _c[1];\n    var idEnabled = Boolean(syntaxDefinition.ids);\n    var classNamesEnabled = Boolean(syntaxDefinition.classNames);\n    var namespaceEnabled = Boolean(syntaxDefinition.namespace);\n    var namespaceWildcardEnabled = syntaxDefinition.namespace &&\n        (syntaxDefinition.namespace === true || syntaxDefinition.namespace.wildcard === true);\n    if (namespaceEnabled && !tagNameEnabled) {\n        throw new Error(\"\".concat(errorPrefix, \"Namespaces cannot be enabled while tags are disabled.\"));\n    }\n    var substitutesEnabled = Boolean(substitutes);\n    var combinatorsIndex = syntaxDefinition.combinators\n        ? createMulticharIndex(syntaxDefinition.combinators)\n        : emptyMulticharIndex;\n    var _d = syntaxDefinition.attributes\n        ? [\n            true,\n            syntaxDefinition.attributes.operators\n                ? createMulticharIndex(syntaxDefinition.attributes.operators)\n                : emptyMulticharIndex,\n            syntaxDefinition.attributes.caseSensitivityModifiers\n                ? createRegularIndex(syntaxDefinition.attributes.caseSensitivityModifiers)\n                : emptyRegularIndex,\n            syntaxDefinition.attributes.unknownCaseSensitivityModifiers === 'accept'\n        ]\n        : [false, emptyMulticharIndex, emptyRegularIndex, false], attributesEnabled = _d[0], attributesOperatorsIndex = _d[1], attributesCaseSensitivityModifiers = _d[2], attributesAcceptUnknownCaseSensitivityModifiers = _d[3];\n    var attributesCaseSensitivityModifiersEnabled = attributesAcceptUnknownCaseSensitivityModifiers || Object.keys(attributesCaseSensitivityModifiers).length > 0;\n    var _e = syntaxDefinition.pseudoClasses\n        ? [\n            true,\n            syntaxDefinition.pseudoClasses.definitions\n                ? calculatePseudoSignatures(syntaxDefinition.pseudoClasses.definitions)\n                : emptyPseudoSignatures,\n            syntaxDefinition.pseudoClasses.unknown === 'accept'\n        ]\n        : [false, emptyPseudoSignatures, false], pseudoClassesEnabled = _e[0], pseudoClassesDefinitions = _e[1], pseudoClassesAcceptUnknown = _e[2];\n    var _f = syntaxDefinition.pseudoElements\n        ? [\n            true,\n            syntaxDefinition.pseudoElements.notation === 'singleColon' ||\n                syntaxDefinition.pseudoElements.notation === 'both',\n            !syntaxDefinition.pseudoElements.notation ||\n                syntaxDefinition.pseudoElements.notation === 'doubleColon' ||\n                syntaxDefinition.pseudoElements.notation === 'both',\n            syntaxDefinition.pseudoElements.definitions\n                ? calculatePseudoSignatures(Array.isArray(syntaxDefinition.pseudoElements.definitions)\n                    ? { NoArgument: syntaxDefinition.pseudoElements.definitions }\n                    : syntaxDefinition.pseudoElements.definitions)\n                : emptyPseudoSignatures,\n            syntaxDefinition.pseudoElements.unknown === 'accept'\n        ]\n        : [false, false, false, emptyPseudoSignatures, false], pseudoElementsEnabled = _f[0], pseudoElementsSingleColonNotationEnabled = _f[1], pseudoElementsDoubleColonNotationEnabled = _f[2], pseudoElementsDefinitions = _f[3], pseudoElementsAcceptUnknown = _f[4];\n    var str = '';\n    var l = str.length;\n    var pos = 0;\n    var chr = '';\n    var is = function (comparison) { return chr === comparison; };\n    var isTagStart = function () { return is('*') || isIdentStart(chr); };\n    var rewind = function (newPos) {\n        pos = newPos;\n        chr = str.charAt(pos);\n    };\n    var next = function () {\n        pos++;\n        chr = str.charAt(pos);\n    };\n    var readAndNext = function () {\n        var current = chr;\n        pos++;\n        chr = str.charAt(pos);\n        return current;\n    };\n    /** @throws ParserError */\n    function fail(errorMessage) {\n        var position = Math.min(l - 1, pos);\n        var error = new Error(\"\".concat(errorPrefix).concat(errorMessage, \" Pos: \").concat(position, \".\"));\n        error.position = position;\n        error.name = 'ParserError';\n        throw error;\n    }\n    function assert(condition, errorMessage) {\n        if (!condition) {\n            return fail(errorMessage);\n        }\n    }\n    var assertNonEof = function () {\n        assert(pos < l, 'Unexpected end of input.');\n    };\n    var isEof = function () { return pos >= l; };\n    var pass = function (character) {\n        assert(pos < l, \"Expected \\\"\".concat(character, \"\\\" but end of input reached.\"));\n        assert(chr === character, \"Expected \\\"\".concat(character, \"\\\" but \\\"\").concat(chr, \"\\\" found.\"));\n        pos++;\n        chr = str.charAt(pos);\n    };\n    function matchMulticharIndex(index) {\n        var match = matchMulticharIndexPos(index, pos);\n        if (match) {\n            pos += match.length;\n            chr = str.charAt(pos);\n            return match;\n        }\n    }\n    function matchMulticharIndexPos(index, subPos) {\n        var char = str.charAt(subPos);\n        var charIndex = index[char];\n        if (charIndex) {\n            var subMatch = matchMulticharIndexPos(charIndex.chars, subPos + 1);\n            if (subMatch) {\n                return subMatch;\n            }\n            if (charIndex.self) {\n                return charIndex.self;\n            }\n        }\n    }\n    /**\n     * @see https://www.w3.org/TR/css-syntax/#hex-digit-diagram\n     */\n    function parseHex() {\n        var hex = readAndNext();\n        var count = 1;\n        while (isHex(chr) && count < maxHexLength) {\n            hex += readAndNext();\n            count++;\n        }\n        skipSingleWhitespace();\n        return String.fromCharCode(parseInt(hex, 16));\n    }\n    /**\n     * @see https://www.w3.org/TR/css-syntax/#string-token-diagram\n     */\n    function parseString(quote) {\n        var result = '';\n        pass(quote);\n        while (pos < l) {\n            if (is(quote)) {\n                next();\n                return result;\n            }\n            else if (is('\\\\')) {\n                next();\n                if (is(quote)) {\n                    result += quote;\n                    next();\n                }\n                else if (chr === '\\n' || chr === '\\f') {\n                    next();\n                }\n                else if (chr === '\\r') {\n                    next();\n                    if (is('\\n')) {\n                        next();\n                    }\n                }\n                else if (isHex(chr)) {\n                    result += parseHex();\n                }\n                else {\n                    result += chr;\n                    next();\n                }\n            }\n            else {\n                result += chr;\n                next();\n            }\n        }\n        return result;\n    }\n    /**\n     * @see https://www.w3.org/TR/css-syntax/#ident-token-diagram\n     */\n    function parseIdentifier() {\n        if (!isIdentStart(chr)) {\n            return null;\n        }\n        var result = '';\n        while (is('-')) {\n            result += chr;\n            next();\n        }\n        if (result === '-' && !isIdent(chr) && !is('\\\\')) {\n            fail('Identifiers cannot consist of a single hyphen.');\n        }\n        if (strict && result.length >= 2) {\n            // Checking this only for strict mode since browsers work fine with these identifiers.\n            fail('Identifiers cannot start with two hyphens with strict mode on.');\n        }\n        if (digitsChars[chr]) {\n            fail('Identifiers cannot start with hyphens followed by digits.');\n        }\n        while (pos < l) {\n            if (isIdent(chr)) {\n                result += readAndNext();\n            }\n            else if (is('\\\\')) {\n                next();\n                assertNonEof();\n                if (isHex(chr)) {\n                    result += parseHex();\n                }\n                else {\n                    result += readAndNext();\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return result;\n    }\n    function parsePseudoClassString() {\n        var result = '';\n        while (pos < l) {\n            if (is(')')) {\n                break;\n            }\n            else if (is('\\\\')) {\n                next();\n                if (isEof() && !strict) {\n                    return (result + '\\\\').trim();\n                }\n                assertNonEof();\n                if (isHex(chr)) {\n                    result += parseHex();\n                }\n                else {\n                    result += readAndNext();\n                }\n            }\n            else {\n                result += readAndNext();\n            }\n        }\n        return result.trim();\n    }\n    function skipSingleWhitespace() {\n        if (chr === ' ' || chr === '\\t' || chr === '\\f' || chr === '\\n') {\n            next();\n            return;\n        }\n        if (chr === '\\r') {\n            next();\n        }\n        if (chr === '\\n') {\n            next();\n        }\n    }\n    function skipWhitespace() {\n        while (whitespaceChars[chr]) {\n            next();\n        }\n    }\n    function parseSelector(relative) {\n        if (relative === void 0) { relative = false; }\n        skipWhitespace();\n        var rules = [parseRule(relative)];\n        while (is(',')) {\n            next();\n            skipWhitespace();\n            rules.push(parseRule(relative));\n        }\n        return {\n            type: 'Selector',\n            rules: rules\n        };\n    }\n    function parseAttribute() {\n        pass('[');\n        skipWhitespace();\n        var attr;\n        if (is('|')) {\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            next();\n            var name_1 = parseIdentifier();\n            assert(name_1, 'Expected attribute name.');\n            attr = {\n                type: 'Attribute',\n                name: name_1,\n                namespace: { type: 'NoNamespace' }\n            };\n        }\n        else if (is('*')) {\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            assert(namespaceWildcardEnabled, 'Wildcard namespace is not enabled.');\n            next();\n            pass('|');\n            var name_2 = parseIdentifier();\n            assert(name_2, 'Expected attribute name.');\n            attr = {\n                type: 'Attribute',\n                name: name_2,\n                namespace: { type: 'WildcardNamespace' }\n            };\n        }\n        else {\n            var identifier = parseIdentifier();\n            assert(identifier, 'Expected attribute name.');\n            attr = {\n                type: 'Attribute',\n                name: identifier\n            };\n            if (is('|')) {\n                var savedPos = pos;\n                next();\n                if (isIdentStart(chr)) {\n                    assert(namespaceEnabled, 'Namespaces are not enabled.');\n                    var name_3 = parseIdentifier();\n                    assert(name_3, 'Expected attribute name.');\n                    attr = {\n                        type: 'Attribute',\n                        name: name_3,\n                        namespace: { type: 'NamespaceName', name: identifier }\n                    };\n                }\n                else {\n                    rewind(savedPos);\n                }\n            }\n        }\n        assert(attr.name, 'Expected attribute name.');\n        skipWhitespace();\n        if (isEof() && !strict) {\n            return attr;\n        }\n        if (is(']')) {\n            next();\n        }\n        else {\n            attr.operator = matchMulticharIndex(attributesOperatorsIndex);\n            assert(attr.operator, 'Expected a valid attribute selector operator.');\n            skipWhitespace();\n            assertNonEof();\n            if (quoteChars[chr]) {\n                attr.value = {\n                    type: 'String',\n                    value: parseString(chr)\n                };\n            }\n            else if (substitutesEnabled && is('$')) {\n                next();\n                var name_4 = parseIdentifier();\n                assert(name_4, 'Expected substitute name.');\n                attr.value = {\n                    type: 'Substitution',\n                    name: name_4\n                };\n            }\n            else {\n                var value = parseIdentifier();\n                assert(value, 'Expected attribute value.');\n                attr.value = {\n                    type: 'String',\n                    value: value\n                };\n            }\n            skipWhitespace();\n            if (isEof() && !strict) {\n                return attr;\n            }\n            if (!is(']')) {\n                var caseSensitivityModifier = parseIdentifier();\n                assert(caseSensitivityModifier, 'Expected end of attribute selector.');\n                attr.caseSensitivityModifier = caseSensitivityModifier;\n                assert(attributesCaseSensitivityModifiersEnabled, 'Attribute case sensitivity modifiers are not enabled.');\n                assert(attributesAcceptUnknownCaseSensitivityModifiers ||\n                    attributesCaseSensitivityModifiers[attr.caseSensitivityModifier], 'Unknown attribute case sensitivity modifier.');\n                skipWhitespace();\n                if (isEof() && !strict) {\n                    return attr;\n                }\n            }\n            pass(']');\n        }\n        return attr;\n    }\n    function parseNumber() {\n        var result = '';\n        while (digitsChars[chr]) {\n            result += readAndNext();\n        }\n        assert(result !== '', 'Formula parse error.');\n        return parseInt(result);\n    }\n    var isNumberStart = function () { return is('-') || is('+') || digitsChars[chr]; };\n    function parseFormula() {\n        if (is('e') || is('o')) {\n            var ident = parseIdentifier();\n            if (ident === 'even') {\n                skipWhitespace();\n                return [2, 0];\n            }\n            if (ident === 'odd') {\n                skipWhitespace();\n                return [2, 1];\n            }\n        }\n        var firstNumber = null;\n        var firstNumberMultiplier = 1;\n        if (is('-')) {\n            next();\n            firstNumberMultiplier = -1;\n        }\n        if (isNumberStart()) {\n            if (is('+')) {\n                next();\n            }\n            firstNumber = parseNumber();\n            if (!is('\\\\') && !is('n')) {\n                return [0, firstNumber * firstNumberMultiplier];\n            }\n        }\n        if (firstNumber === null) {\n            firstNumber = 1;\n        }\n        firstNumber *= firstNumberMultiplier;\n        var identifier;\n        if (is('\\\\')) {\n            next();\n            if (isHex(chr)) {\n                identifier = parseHex();\n            }\n            else {\n                identifier = readAndNext();\n            }\n        }\n        else {\n            identifier = readAndNext();\n        }\n        assert(identifier === 'n', 'Formula parse error: expected \"n\".');\n        skipWhitespace();\n        if (is('+') || is('-')) {\n            var sign = is('+') ? 1 : -1;\n            next();\n            skipWhitespace();\n            return [firstNumber, sign * parseNumber()];\n        }\n        else {\n            return [firstNumber, 0];\n        }\n    }\n    function parsePseudoArgument(pseudoName, type, signature) {\n        var argument;\n        if (is('(')) {\n            next();\n            skipWhitespace();\n            if (substitutesEnabled && is('$')) {\n                next();\n                var name_5 = parseIdentifier();\n                assert(name_5, 'Expected substitute name.');\n                argument = {\n                    type: 'Substitution',\n                    name: name_5\n                };\n            }\n            else if (signature.type === 'String') {\n                argument = {\n                    type: 'String',\n                    value: parsePseudoClassString()\n                };\n                assert(argument.value, \"Expected \".concat(type, \" argument value.\"));\n            }\n            else if (signature.type === 'Selector') {\n                argument = parseSelector(true);\n            }\n            else if (signature.type === 'Formula') {\n                var _a = parseFormula(), a = _a[0], b = _a[1];\n                argument = {\n                    type: 'Formula',\n                    a: a,\n                    b: b\n                };\n                if (signature.ofSelector) {\n                    skipWhitespace();\n                    if (is('o') || is('\\\\')) {\n                        var ident = parseIdentifier();\n                        assert(ident === 'of', 'Formula of selector parse error.');\n                        skipWhitespace();\n                        argument = {\n                            type: 'FormulaOfSelector',\n                            a: a,\n                            b: b,\n                            selector: parseRule()\n                        };\n                    }\n                }\n            }\n            else {\n                return fail(\"Invalid \".concat(type, \" signature.\"));\n            }\n            skipWhitespace();\n            if (isEof() && !strict) {\n                return argument;\n            }\n            pass(')');\n        }\n        else {\n            assert(signature.optional, \"Argument is required for \".concat(type, \" \\\"\").concat(pseudoName, \"\\\".\"));\n        }\n        return argument;\n    }\n    function parseTagName() {\n        if (is('*')) {\n            assert(tagNameWildcardEnabled, 'Wildcard tag name is not enabled.');\n            next();\n            return { type: 'WildcardTag' };\n        }\n        else if (isIdentStart(chr)) {\n            assert(tagNameEnabled, 'Tag names are not enabled.');\n            var name_6 = parseIdentifier();\n            assert(name_6, 'Expected tag name.');\n            return {\n                type: 'TagName',\n                name: name_6\n            };\n        }\n        else {\n            return fail('Expected tag name.');\n        }\n    }\n    function parseTagNameWithNamespace() {\n        if (is('*')) {\n            var savedPos = pos;\n            next();\n            if (!is('|')) {\n                rewind(savedPos);\n                return parseTagName();\n            }\n            next();\n            if (!isTagStart()) {\n                rewind(savedPos);\n                return parseTagName();\n            }\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            assert(namespaceWildcardEnabled, 'Wildcard namespace is not enabled.');\n            var tagName = parseTagName();\n            tagName.namespace = { type: 'WildcardNamespace' };\n            return tagName;\n        }\n        else if (is('|')) {\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            next();\n            var tagName = parseTagName();\n            tagName.namespace = { type: 'NoNamespace' };\n            return tagName;\n        }\n        else if (isIdentStart(chr)) {\n            var identifier = parseIdentifier();\n            assert(identifier, 'Expected tag name.');\n            if (!is('|')) {\n                assert(tagNameEnabled, 'Tag names are not enabled.');\n                return {\n                    type: 'TagName',\n                    name: identifier\n                };\n            }\n            var savedPos = pos;\n            next();\n            if (!isTagStart()) {\n                rewind(savedPos);\n                return {\n                    type: 'TagName',\n                    name: identifier\n                };\n            }\n            assert(namespaceEnabled, 'Namespaces are not enabled.');\n            var tagName = parseTagName();\n            tagName.namespace = { type: 'NamespaceName', name: identifier };\n            return tagName;\n        }\n        else {\n            return fail('Expected tag name.');\n        }\n    }\n    function parseRule(relative) {\n        var _a, _b;\n        if (relative === void 0) { relative = false; }\n        var rule = { type: 'Rule', items: [] };\n        if (relative) {\n            var combinator = matchMulticharIndex(combinatorsIndex);\n            if (combinator) {\n                rule.combinator = combinator;\n                skipWhitespace();\n            }\n        }\n        while (pos < l) {\n            if (isTagStart()) {\n                assert(rule.items.length === 0, 'Unexpected tag/namespace start.');\n                rule.items.push(parseTagNameWithNamespace());\n            }\n            else if (is('|')) {\n                var savedPos = pos;\n                next();\n                if (isTagStart()) {\n                    assert(rule.items.length === 0, 'Unexpected tag/namespace start.');\n                    rewind(savedPos);\n                    rule.items.push(parseTagNameWithNamespace());\n                }\n                else {\n                    rewind(savedPos);\n                    break;\n                }\n            }\n            else if (is('.')) {\n                assert(classNamesEnabled, 'Class names are not enabled.');\n                next();\n                var className = parseIdentifier();\n                assert(className, 'Expected class name.');\n                rule.items.push({ type: 'ClassName', name: className });\n            }\n            else if (is('#')) {\n                assert(idEnabled, 'IDs are not enabled.');\n                next();\n                var idName = parseIdentifier();\n                assert(idName, 'Expected ID name.');\n                rule.items.push({ type: 'Id', name: idName });\n            }\n            else if (is('[')) {\n                assert(attributesEnabled, 'Attributes are not enabled.');\n                rule.items.push(parseAttribute());\n            }\n            else if (is(':')) {\n                var isDoubleColon = false;\n                var isPseudoElement = false;\n                next();\n                if (is(':')) {\n                    assert(pseudoElementsEnabled, 'Pseudo elements are not enabled.');\n                    assert(pseudoElementsDoubleColonNotationEnabled, 'Pseudo elements double colon notation is not enabled.');\n                    isDoubleColon = true;\n                    next();\n                }\n                var pseudoName = parseIdentifier();\n                assert(isDoubleColon || pseudoName, 'Expected pseudo-class name.');\n                assert(!isDoubleColon || pseudoName, 'Expected pseudo-element name.');\n                assert(pseudoName, 'Expected pseudo-class name.');\n                assert(!isDoubleColon ||\n                    pseudoElementsAcceptUnknown ||\n                    Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName), \"Unknown pseudo-element \\\"\".concat(pseudoName, \"\\\".\"));\n                isPseudoElement =\n                    pseudoElementsEnabled &&\n                        (isDoubleColon ||\n                            (!isDoubleColon &&\n                                pseudoElementsSingleColonNotationEnabled &&\n                                Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName)));\n                if (isPseudoElement) {\n                    var signature = (_a = pseudoElementsDefinitions[pseudoName]) !== null && _a !== void 0 ? _a : (pseudoElementsAcceptUnknown && defaultPseudoSignature);\n                    var pseudoElement = {\n                        type: 'PseudoElement',\n                        name: pseudoName\n                    };\n                    var argument = parsePseudoArgument(pseudoName, 'pseudo-element', signature);\n                    if (argument) {\n                        assert(argument.type !== 'Formula' && argument.type !== 'FormulaOfSelector', 'Pseudo-elements cannot have formula argument.');\n                        pseudoElement.argument = argument;\n                    }\n                    rule.items.push(pseudoElement);\n                }\n                else {\n                    assert(pseudoClassesEnabled, 'Pseudo-classes are not enabled.');\n                    var signature = (_b = pseudoClassesDefinitions[pseudoName]) !== null && _b !== void 0 ? _b : (pseudoClassesAcceptUnknown && defaultPseudoSignature);\n                    assert(signature, \"Unknown pseudo-class: \\\"\".concat(pseudoName, \"\\\".\"));\n                    var argument = parsePseudoArgument(pseudoName, 'pseudo-class', signature);\n                    var pseudoClass = {\n                        type: 'PseudoClass',\n                        name: pseudoName\n                    };\n                    if (argument) {\n                        pseudoClass.argument = argument;\n                    }\n                    rule.items.push(pseudoClass);\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (rule.items.length === 0) {\n            if (isEof()) {\n                return fail('Expected rule but end of input reached.');\n            }\n            else {\n                return fail(\"Expected rule but \\\"\".concat(chr, \"\\\" found.\"));\n            }\n        }\n        skipWhitespace();\n        if (!isEof() && !is(',') && !is(')')) {\n            var combinator = matchMulticharIndex(combinatorsIndex);\n            skipWhitespace();\n            rule.nestedRule = parseRule();\n            rule.nestedRule.combinator = combinator;\n        }\n        return rule;\n    }\n    return function (input) {\n        // noinspection SuspiciousTypeOfGuard\n        if (typeof input !== 'string') {\n            throw new Error(\"\".concat(errorPrefix, \"Expected string input.\"));\n        }\n        str = input;\n        l = str.length;\n        pos = 0;\n        chr = str.charAt(0);\n        return parseSelector();\n    };\n}\n", "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction astMethods(type) {\n    return function (generatorName, checkerName) {\n        var _a;\n        return (_a = {},\n            _a[generatorName] = function (props) { return (__assign({ type: type }, props)); },\n            _a[checkerName] = function (entity) {\n                return typeof entity === 'object' && entity !== null && entity.type === type;\n            },\n            _a);\n    };\n}\n/**\n * AST structure generators and matchers.\n * For instance, `ast.selector({rules: [...]})` creates AstSelector and `ast.isSelector(...)` checks if\n * AstSelector was specified.\n *\n * @example\n *\n * // Represents CSS selector: ns|div#user-34.user.user-active[role=\"button\"]:lang(en)::before > *\n * const selector = ast.selector({\n *     rules: [\n *         ast.rule({\n *             items: [\n *                 ast.tagName({name: 'div', namespace: ast.namespaceName({name: 'ns'})}),\n *                 ast.id({name: 'user-34'}),\n *                 ast.className({name: 'user'}),\n *                 ast.className({name: 'user-active'}),\n *                 ast.attribute({\n *                     name: 'role',\n *                     operator: '=',\n *                     value: ast.string({value: 'button'})\n *                 }),\n *                 ast.pseudoClass({\n *                     name: 'lang',\n *                     argument: ast.string({value: 'en'})\n *                 }),\n *                 ast.pseudoElement({name: 'before'})\n *             ],\n *             nestedRule: ast.rule({combinator: '>', items: [ast.wildcardTag()]})\n *         })\n *     ]\n * });\n * console.log(ast.isSelector(selector)); // prints true\n * console.log(ast.isRule(selector)); // prints false\n */\nexport var ast = __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, astMethods('Selector')('selector', 'isSelector')), astMethods('Rule')('rule', 'isRule')), astMethods('TagName')('tagName', 'isTagName')), astMethods('Id')('id', 'isId')), astMethods('ClassName')('className', 'isClassName')), astMethods('WildcardTag')('wildcardTag', 'isWildcardTag')), astMethods('NamespaceName')('namespaceName', 'isNamespaceName')), astMethods('WildcardNamespace')('wildcardNamespace', 'isWildcardNamespace')), astMethods('NoNamespace')('noNamespace', 'isNoNamespace')), astMethods('Attribute')('attribute', 'isAttribute')), astMethods('PseudoClass')('pseudoClass', 'isPseudoClass')), astMethods('PseudoElement')('pseudoElement', 'isPseudoElement')), astMethods('String')('string', 'isString')), astMethods('Formula')('formula', 'isFormula')), astMethods('FormulaOfSelector')('formulaOfSelector', 'isFormulaOfSelector')), astMethods('Substitution')('substitution', 'isSubstitution'));\n", "/**\n * @typedef {import('css-selector-parser').AstSelector} AstSelector\n */\n\nimport {createParser} from 'css-selector-parser'\n\nconst cssSelectorParse = createParser({syntax: 'selectors-4'})\n\n/**\n * @param {string} selector\n *   Selector to parse.\n * @returns {AstSelector}\n *   Parsed selector.\n */\nexport function parse(selector) {\n  if (typeof selector !== 'string') {\n    throw new TypeError('Expected `string` as selector, not `' + selector + '`')\n  }\n\n  return cssSelectorParse(selector)\n}\n", "const rtlRange = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nconst ltrRange =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\n/* eslint-disable no-misleading-character-class */\nconst rtl = new RegExp('^[^' + ltrRange + ']*[' + rtlRange + ']')\nconst ltr = new RegExp('^[^' + rtlRange + ']*[' + ltrRange + ']')\n/* eslint-enable no-misleading-character-class */\n\n/**\n * Detect the direction of text: left-to-right, right-to-left, or neutral\n *\n * @param {string} value\n * @returns {'rtl'|'ltr'|'neutral'}\n */\nexport function direction(value) {\n  const source = String(value || '')\n  return rtl.test(source) ? 'rtl' : ltr.test(source) ? 'ltr' : 'neutral'\n}\n", "/**\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n *\n * @typedef {import('unist-util-visit').Visitor<ElementContent>} Visitor\n *\n * @typedef {import('./index.js').Direction} Direction\n * @typedef {import('./index.js').State} State\n */\n\nimport {direction} from 'direction'\nimport {toString} from 'hast-util-to-string'\nimport {svg} from 'property-information'\nimport {EXIT, SKIP, visit} from 'unist-util-visit'\n\n/**\n * Enter a node.\n *\n * The caller is responsible for calling the return value `exit`.\n *\n * @param {State} state\n *   Current state.\n *\n *   Will be mutated: `exit` undos the changes.\n * @param {Nodes} node\n *   Node to enter.\n * @returns {() => undefined}\n *   Call to exit.\n */\n// eslint-disable-next-line complexity\nexport function enterState(state, node) {\n  const schema = state.schema\n  const language = state.language\n  const currentDirection = state.direction\n  const editableOrEditingHost = state.editableOrEditingHost\n  /** @type {Direction | undefined} */\n  let dirInferred\n\n  if (node.type === 'element') {\n    const lang = node.properties.xmlLang || node.properties.lang\n    const type = node.properties.type || 'text'\n    const dir = dirProperty(node)\n\n    if (lang !== null && lang !== undefined) {\n      state.language = String(lang)\n    }\n\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true\n      }\n\n      if (node.tagName === 'svg') {\n        state.schema = svg\n      }\n\n      // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n      if (dir === 'rtl') {\n        dirInferred = dir\n      } else if (\n        // Explicit `[dir=ltr]`.\n        dir === 'ltr' ||\n        // HTML with an invalid or no `[dir]`.\n        (dir !== 'auto' && node.tagName === 'html') ||\n        // `input[type=tel]` with an invalid or no `[dir]`.\n        (dir !== 'auto' && node.tagName === 'input' && type === 'tel')\n      ) {\n        dirInferred = 'ltr'\n        // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || node.tagName === 'bdi') {\n        if (node.tagName === 'textarea') {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi(toString(node))\n        } else if (\n          node.tagName === 'input' &&\n          (type === 'email' ||\n            type === 'search' ||\n            type === 'tel' ||\n            type === 'text')\n        ) {\n          // Check value of `<input>`.\n          dirInferred = node.properties.value\n            ? dirBidi(String(node.properties.value))\n            : 'ltr'\n        } else {\n          // Check text nodes in `node`.\n          visit(node, inferDirectionality)\n        }\n      }\n\n      if (dirInferred) {\n        state.direction = dirInferred\n      }\n    }\n    // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false\n    }\n  }\n\n  return reset\n\n  /**\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function reset() {\n    state.schema = schema\n    state.language = language\n    state.direction = currentDirection\n    state.editableOrEditingHost = editableOrEditingHost\n  }\n\n  /** @type {Visitor} */\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value)\n      return dirInferred ? EXIT : undefined\n    }\n\n    if (\n      child !== node &&\n      child.type === 'element' &&\n      (child.tagName === 'bdi' ||\n        child.tagName === 'script' ||\n        child.tagName === 'style' ||\n        child.tagName === 'textare' ||\n        dirProperty(child))\n    ) {\n      return SKIP\n    }\n  }\n}\n\n/**\n * See `wooorm/direction`.\n *\n * @param {string} value\n *   Value to check.\n * @returns {Exclude<Direction, 'auto'> | undefined}\n *   Directionality.\n */\nfunction dirBidi(value) {\n  const result = direction(value)\n  return result === 'neutral' ? undefined : result\n}\n\n/**\n * @param {ElementContent} node\n *   Node to check.\n * @returns {Direction | undefined}\n *   Directionality.\n */\nfunction dirProperty(node) {\n  const value =\n    node.type === 'element' && typeof node.properties.dir === 'string'\n      ? node.properties.dir.toLowerCase()\n      : undefined\n\n  return value === 'auto' || value === 'ltr' || value === 'rtl'\n    ? value\n    : undefined\n}\n", "/**\n * @typedef {import('css-selector-parser').AstAttribute} AstAttribute\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n *\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {find} from 'property-information'\nimport * as spaces from 'space-separated-tokens'\n\n/**\n * @param {AstAttribute} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {Schema} schema\n *   Schema of element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nexport function attribute(query, element, schema) {\n  const info = find(schema, query.name)\n  const propertyValue = element.properties[info.property]\n  let value = normalizeValue(propertyValue, info)\n\n  // Exists.\n  if (!query.value) {\n    return value !== undefined\n  }\n\n  assert(query.value.type === 'String', 'expected plain string')\n  let key = query.value.value\n\n  // Case-sensitivity.\n  if (query.caseSensitivityModifier === 'i') {\n    key = key.toLowerCase()\n\n    if (value) {\n      value = value.toLowerCase()\n    }\n  }\n\n  if (value !== undefined) {\n    switch (query.operator) {\n      // Exact.\n      case '=': {\n        return key === value\n      }\n\n      // Ends.\n      case '$=': {\n        return key === value.slice(-key.length)\n      }\n\n      // Contains.\n      case '*=': {\n        return value.includes(key)\n      }\n\n      // Begins.\n      case '^=': {\n        return key === value.slice(0, key.length)\n      }\n\n      // Exact or prefix.\n      case '|=': {\n        return (\n          key === value ||\n          (key === value.slice(0, key.length) &&\n            value.charAt(key.length) === '-')\n        )\n      }\n\n      // Space-separated list.\n      case '~=': {\n        return (\n          // For all other values (including comma-separated lists), return whether this\n          // is an exact match.\n          key === value ||\n          // If this is a space-separated list, and the query is contained in it, return\n          // true.\n          spaces.parse(value).includes(key)\n        )\n      }\n      // Other values are not yet supported by CSS.\n      // No default\n    }\n  }\n\n  return false\n}\n\n/**\n *\n * @param {Properties[keyof Properties]} value\n * @param {Info} info\n * @returns {string | undefined}\n */\nfunction normalizeValue(value, info) {\n  if (value === null || value === undefined) {\n    // Empty.\n  } else if (typeof value === 'boolean') {\n    if (value) {\n      return info.attribute\n    }\n  } else if (Array.isArray(value)) {\n    if (value.length > 0) {\n      return (info.commaSeparated ? commas : spaces.stringify)(value)\n    }\n  } else {\n    return String(value)\n  }\n}\n", "/**\n * @typedef {import('css-selector-parser').AstClassName} AstClassName\n * @typedef {import('hast').Element} Element\n */\n\n/** @type {Array<never>} */\nconst emptyClassNames = []\n\n/**\n * Check whether an element has all class names.\n *\n * @param {AstClassName} query\n *   AST rule (with `classNames`).\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nexport function className(query, element) {\n  // Assume array.\n  const value = /** @type {Readonly<Array<string>>} */ (\n    element.properties.className || emptyClassNames\n  )\n\n  return value.includes(query.name)\n}\n", "/**\n * @typedef {import('css-selector-parser').AstId} AstId\n *\n * @typedef {import('hast').Element} Element\n */\n\n// Workaround to show references to above types in VS Code.\n''\n\n/**\n * Check whether an element has an ID.\n *\n * @param {AstId} query\n *   AST rule (with `ids`).\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nexport function id(query, element) {\n  return element.properties.id === query.name\n}\n", "/**\n * @typedef {import('css-selector-parser').AstTagName} AstTagName\n *\n * @typedef {import('hast').Element} Element\n */\n\n// Workaround to show references to above types in VS Code.\n''\n\n/**\n * Check whether an element has a tag name.\n *\n * @param {AstTagName} query\n *   AST rule (with `tag`).\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nexport function name(query, element) {\n  return query.name === element.tagName\n}\n", "/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more info on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n *   BCP-47 tag.\n * @typedef {Array<Tag>} Tags\n *   List of BCP-47 tags.\n * @typedef {string} Range\n *   RFC 4647 range.\n * @typedef {Array<Range>} Ranges\n *   List of RFC 4647 range.\n *\n * @callback Check\n *   An internal check.\n * @param {Tag} tag\n *   BCP-47 tag.\n * @param {Range} range\n *   RFC 4647 range.\n * @returns {boolean}\n *   Whether the range matches the tag.\n *\n * @typedef {FilterOrLookup<true>} Filter\n *   Filter: yields all tags that match a range.\n * @typedef {FilterOrLookup<false>} Lookup\n *   Lookup: yields the best tag that matches a range.\n */\n\n/**\n * @template {boolean} IsFilter\n *   Whether to filter or perform a lookup.\n * @callback FilterOrLookup\n *   A check.\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\n *   Result.\n */\n\n/**\n * Factory to perform a filter or a lookup.\n *\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.\n * That way, earlier ranges matching any tag have precedence over later ranges.\n *\n * @template {boolean} IsFilter\n * @param {Check} check\n *   A check.\n * @param {IsFilter} filter\n *   Whether to filter or perform a lookup.\n * @returns {FilterOrLookup<IsFilter>}\n *   Filter or lookup.\n */\nfunction factory(check, filter) {\n  /**\n   * @param {Tag|Tags} tags\n   *   One or more BCP-47 tags.\n   * @param {Range|Ranges|undefined} [ranges='*']\n   *   One or more RFC 4647 ranges.\n   * @returns {IsFilter extends true ? Tags : Tag|undefined}\n   *   Result.\n   */\n  return function (tags, ranges) {\n    let left = cast(tags, 'tag')\n    const right = cast(\n      ranges === null || ranges === undefined ? '*' : ranges,\n      'range'\n    )\n    /** @type {Tags} */\n    const matches = []\n    let rightIndex = -1\n\n    while (++rightIndex < right.length) {\n      const range = right[rightIndex].toLowerCase()\n\n      // Ignore wildcards in lookup mode.\n      if (!filter && range === '*') continue\n\n      let leftIndex = -1\n      /** @type {Tags} */\n      const next = []\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) {\n            return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (\n              left[leftIndex]\n            )\n          }\n\n          matches.push(left[leftIndex])\n        } else {\n          next.push(left[leftIndex])\n        }\n      }\n\n      left = next\n    }\n\n    // If this is a filter, return the list.  If its a lookup, we didnt find\n    // a match, so return `undefined`.\n    return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (\n      filter ? matches : undefined\n    )\n  }\n}\n\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\nexport const basicFilter = factory(function (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-')\n}, true)\n\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\nexport const extendedFilter = factory(function (tag, range) {\n  // 3.3.2.1\n  const left = tag.split('-')\n  const right = range.split('-')\n  let leftIndex = 0\n  let rightIndex = 0\n\n  // 3.3.2.2\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false\n  }\n\n  leftIndex++\n  rightIndex++\n\n  // 3.3.2.3\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++\n      continue\n    }\n\n    // 3.3.2.3.B\n    if (!left[leftIndex]) return false\n\n    // 3.3.2.3.C\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++\n      rightIndex++\n      continue\n    }\n\n    // 3.3.2.3.D\n    if (left[leftIndex].length === 1) return false\n\n    // 3.3.2.3.E\n    leftIndex++\n  }\n\n  // 3.3.2.4\n  return true\n}, true)\n\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tag|undefined}\n *   BCP-47 tag.\n */\nexport const lookup = factory(function (tag, range) {\n  let right = range\n\n  /* eslint-disable-next-line no-constant-condition */\n  while (true) {\n    if (right === '*' || tag === right) return true\n\n    let index = right.lastIndexOf('-')\n\n    if (index < 0) return false\n\n    if (right.charAt(index - 2) === '-') index -= 2\n\n    right = right.slice(0, index)\n  }\n}, false)\n\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error(\n      'Invalid ' + name + ' `' + value + '`, expected non-empty string'\n    )\n  }\n\n  return value\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Check if `node` is an element and has a `name` property.\n *\n * @template {string} Key\n *   Type of key.\n * @param {Nodes} node\n *   Node to check (typically `Element`).\n * @param {Key} name\n *   Property name to check.\n * @returns {node is Element & {properties: Record<Key, Array<number | string> | number | string | true>}}}\n *   Whether `node` is an element that has a `name` property.\n *\n *   Note: see <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/27c9274/types/hast/index.d.ts#L37C29-L37C98>.\n */\nexport function hasProperty(node, name) {\n  const value =\n    node.type === 'element' &&\n    own.call(node.properties, name) &&\n    node.properties[name]\n\n  return value !== null && value !== undefined && value !== false\n}\n", null, null, null, "/**\n * @typedef {import('css-selector-parser').AstPseudoClass} AstPseudoClass\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Parents} Parents\n *\n * @typedef {import('./index.js').State} State\n */\n\nimport {extendedFilter} from 'bcp-47-match'\nimport {parse as commas} from 'comma-separated-tokens'\nimport {ok as assert, unreachable} from 'devlop'\nimport {hasProperty} from 'hast-util-has-property'\nimport {whitespace} from 'hast-util-whitespace'\nimport fauxEsmNthCheck from 'nth-check'\nimport {zwitch} from 'zwitch'\nimport {walk} from './walk.js'\n\n/** @type {import('nth-check').default} */\n// @ts-expect-error: types are broken.\nconst nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck\n\n/** @type {(rule: AstPseudoClass, element: Element, index: number | undefined, parent: Parents | undefined, state: State) => boolean} */\nexport const pseudo = zwitch('name', {\n  handlers: {\n    'any-link': anyLink,\n    blank,\n    checked,\n    dir,\n    disabled,\n    empty,\n    enabled,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    is,\n    lang,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-last-of-type': nthLastOfType,\n    'nth-of-type': nthOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    optional,\n    'read-only': readOnly,\n    'read-write': readWrite,\n    required,\n    root,\n    scope\n  },\n  invalid: invalidPseudo,\n  unknown: unknownPseudo\n})\n\n/**\n * Check whether an element matches an `:any-link` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction anyLink(_, element) {\n  return (\n    (element.tagName === 'a' ||\n      element.tagName === 'area' ||\n      element.tagName === 'link') &&\n    hasProperty(element, 'href')\n  )\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {AstPseudoClass} query\n *   Query.\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent')\n  }\n}\n\n/**\n * Check whether an element matches a `:blank` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction blank(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementContent} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return (\n      child.type === 'element' || (child.type === 'text' && !whitespace(child))\n    )\n  }\n}\n\n/**\n * Check whether an element matches a `:checked` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction checked(_, element) {\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\n    return Boolean(\n      (element.properties.type === 'checkbox' ||\n        element.properties.type === 'radio') &&\n        hasProperty(element, 'checked')\n    )\n  }\n\n  if (element.tagName === 'option') {\n    return hasProperty(element, 'selected')\n  }\n\n  return false\n}\n\n/**\n * Check whether an element matches a `:dir()` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction dir(query, _1, _2, _3, state) {\n  assert(query.argument, 'expected `argument`')\n  assert(query.argument.type === 'String', 'expected plain text')\n  return state.direction === query.argument.value\n}\n\n/**\n * Check whether an element matches a `:disabled` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction disabled(_, element) {\n  return (\n    (element.tagName === 'button' ||\n      element.tagName === 'input' ||\n      element.tagName === 'select' ||\n      element.tagName === 'textarea' ||\n      element.tagName === 'optgroup' ||\n      element.tagName === 'option' ||\n      element.tagName === 'menuitem' ||\n      element.tagName === 'fieldset') &&\n    hasProperty(element, 'disabled')\n  )\n}\n\n/**\n * Check whether an element matches an `:empty` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction empty(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementContent} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text'\n  }\n}\n\n/**\n * Check whether an element matches an `:enabled` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction enabled(query, element) {\n  return !disabled(query, element)\n}\n\n/**\n * Check whether an element matches a `:first-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementIndex === 0\n}\n\n/**\n * Check whether an element matches a `:first-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeIndex === 0\n}\n\n/**\n * @param {AstPseudoClass} query\n *   Query.\n * @returns {(value: number) => boolean}\n *   N.\n */\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let fn = query._cachedFn\n\n  if (!fn) {\n    const value = query.argument\n    assert(value, 'expected `argument`')\n\n    if (value.type !== 'Formula') {\n      throw new Error(\n        'Expected `nth` formula, such as `even` or `2n+1` (`of` is not yet supported)'\n      )\n    }\n\n    fn = nthCheck(value.a + 'n+' + value.b)\n    // @ts-expect-error: cache.\n    query._cachedFn = fn\n  }\n\n  return fn\n}\n\n/**\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction has(query, element, _1, _2, state) {\n  assert(query.argument, 'expected `argument`')\n  assert(query.argument.type === 'Selector', 'expected selector')\n\n  /** @type {State} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // One result is enough.\n    one: true,\n    results: [],\n    rootQuery: query.argument,\n    scopeElements: [element],\n    // Do walk deep.\n    shallow: false\n  }\n\n  walk(childState, {type: 'root', children: element.children})\n\n  return childState.results.length > 0\n}\n\n// Shouldnt be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  unreachable('Invalid pseudo-selector')\n}\n\n/**\n * Check whether an element `:is` further selectors.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction is(query, element, _1, _2, state) {\n  assert(query.argument, 'expected `argument`')\n  assert(query.argument.type === 'Selector', 'expected selector')\n\n  /** @type {State} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // One result is enough.\n    one: true,\n    results: [],\n    rootQuery: query.argument,\n    scopeElements: [element],\n    // Do walk deep.\n    shallow: false\n  }\n\n  walk(childState, element)\n\n  return childState.results[0] === element\n}\n\n/**\n * Check whether an element matches a `:lang()` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lang(query, _1, _2, _3, state) {\n  assert(query.argument, 'expected `argument`')\n  assert(query.argument.type === 'String', 'expected string')\n\n  return (\n    state.language !== '' &&\n    state.language !== undefined &&\n    extendedFilter(state.language, commas(query.argument.value)).length > 0\n  )\n}\n\n/**\n * Check whether an element matches a `:last-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return Boolean(\n    state.elementCount && state.elementIndex === state.elementCount - 1\n  )\n}\n\n/**\n * Check whether an element matches a `:last-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.typeIndex === 'number' &&\n    typeof state.typeCount === 'number' &&\n    state.typeIndex === state.typeCount - 1\n  )\n}\n\n/**\n * Check whether an element does `:not` match further selectors.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} index\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction not(query, element, index, parent, state) {\n  return !is(query, element, index, parent, state)\n}\n\n/**\n * Check whether an element matches an `:nth-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.elementIndex === 'number' && fn(state.elementIndex)\n}\n\n/**\n * Check whether an element matches an `:nth-last-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return Boolean(\n    typeof state.elementCount === 'number' &&\n      typeof state.elementIndex === 'number' &&\n      fn(state.elementCount - state.elementIndex - 1)\n  )\n}\n\n/**\n * Check whether an element matches a `:nth-last-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.typeCount === 'number' &&\n    typeof state.typeIndex === 'number' &&\n    fn(state.typeCount - 1 - state.typeIndex)\n  )\n}\n\n/**\n * Check whether an element matches an `:nth-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex)\n}\n\n/**\n * Check whether an element matches an `:only-child` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementCount === 1\n}\n\n/**\n * Check whether an element matches an `:only-of-type` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} _1\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeCount === 1\n}\n\n/**\n * Check whether an element matches an `:optional` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction optional(query, element) {\n  return !required(query, element)\n}\n\n/**\n * Check whether an element matches a `:read-only` pseudo.\n *\n * @param {AstPseudoClass} query\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} index\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state)\n}\n\n/**\n * Check whether an element matches a `:read-write` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _1\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _2\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction readWrite(_, element, _1, _2, state) {\n  return element.tagName === 'input' || element.tagName === 'textarea'\n    ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled')\n    : Boolean(state.editableOrEditingHost)\n}\n\n/**\n * Check whether an element matches a `:required` pseudo.\n *\n * @param {AstPseudoClass} _\n *   Query.\n * @param {Element} element\n *   Element.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction required(_, element) {\n  return (\n    (element.tagName === 'input' ||\n      element.tagName === 'textarea' ||\n      element.tagName === 'select') &&\n    hasProperty(element, 'required')\n  )\n}\n\n/**\n * Check whether an element matches a `:root` pseudo.\n *\n * @param {AstPseudoClass} _1\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction root(_1, element, _2, parent, state) {\n  return Boolean(\n    (!parent || parent.type === 'root') &&\n      state.schema &&\n      (state.schema.space === 'html' || state.schema.space === 'svg') &&\n      (element.tagName === 'html' || element.tagName === 'svg')\n  )\n}\n\n/**\n * Check whether an element matches a `:scope` pseudo.\n *\n * @param {AstPseudoClass} _1\n *   Query.\n * @param {Element} element\n *   Element.\n * @param {number | undefined} _2\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} _3\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nfunction scope(_1, element, _2, _3, state) {\n  return state.scopeElements.includes(element)\n}\n\n/**\n * Check children.\n *\n * @param {Element} element\n *   Element.\n * @param {(child: ElementContent) => boolean} check\n *   Check.\n * @returns {boolean}\n *   Whether a child of `element` matches `check`.\n */\nfunction someChildren(element, check) {\n  const children = element.children\n  let index = -1\n\n  while (++index < children.length) {\n    if (check(children[index])) return true\n  }\n\n  return false\n}\n\n/**\n * @param {unknown} query_\n *   Query-like value.\n * @returns {never}\n *   Nothing.\n * @throws\n *   Exception.\n */\nfunction unknownPseudo(query_) {\n  // Runtime JS guarantees it has a `name`.\n  const query = /** @type {AstPseudoClass} */ (query_)\n  throw new Error('Unknown pseudo-selector `' + query.name + '`')\n}\n", "/**\n * @typedef {import('css-selector-parser').AstRule} AstRule\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Parents} Parents\n *\n * @typedef {import('./index.js').State} State\n */\n\nimport {attribute} from './attribute.js'\nimport {className} from './class-name.js'\nimport {id} from './id.js'\nimport {name} from './name.js'\nimport {pseudo} from './pseudo.js'\n\n/**\n * Test a rule.\n *\n * @param {AstRule} query\n *   AST rule (with `pseudoClasses`).\n * @param {Element} element\n *   Element.\n * @param {number | undefined} index\n *   Index of `element` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @param {State} state\n *   State.\n * @returns {boolean}\n *   Whether `element` matches `query`.\n */\nexport function test(query, element, index, parent, state) {\n  for (const item of query.items) {\n    // eslint-disable-next-line unicorn/prefer-switch\n    if (item.type === 'Attribute') {\n      if (!attribute(item, element, state.schema)) return false\n    } else if (item.type === 'Id') {\n      if (!id(item, element)) return false\n    } else if (item.type === 'ClassName') {\n      if (!className(item, element)) return false\n    } else if (item.type === 'PseudoClass') {\n      if (!pseudo(item, element, index, parent, state)) return false\n    } else if (item.type === 'PseudoElement') {\n      throw new Error('Invalid selector: `::' + item.name + '`')\n    } else if (item.type === 'TagName') {\n      if (!name(item, element)) return false\n    } else {\n      // Otherwise `item.type` is `WildcardTag`, which matches.\n    }\n  }\n\n  return true\n}\n", "/**\n * @typedef {import('css-selector-parser').AstRule} AstRule\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n *\n * @typedef {import('./index.js').State} State\n */\n\n/**\n * @typedef Counts\n *   Info on elements in a parent.\n * @property {number} count\n *   Number of elements.\n * @property {Map<string, number>} types\n *   Number of elements by tag name.\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<AstRule> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<AstRule> | undefined} descendant\n *   `a b`\n * @property {Array<AstRule> | undefined} directChild\n *   `a > b`\n * @property {Array<AstRule> | undefined} generalSibling\n *   `a ~ b`\n */\n\nimport {enterState} from './enter-state.js'\nimport {test} from './test.js'\n\n/** @type {Array<never>} */\nconst empty = []\n\n/**\n * Walk a tree.\n *\n * @param {State} state\n *   State.\n * @param {Nodes | undefined} tree\n *   Tree.\n */\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined, tree)\n  }\n}\n\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n *   Nesting.\n * @param {keyof Nest} field\n *   Field.\n * @param {AstRule} rule\n *   Rule.\n */\nfunction add(nest, field, rule) {\n  const list = nest[field]\n  if (list) {\n    list.push(rule)\n  } else {\n    nest[field] = [rule]\n  }\n}\n\n/**\n * Check in a parent.\n *\n * @param {State} state\n *   State.\n * @param {Nest} nest\n *   Nesting.\n * @param {Parents} node\n *   Parent.\n * @param {Nodes} tree\n *   Tree.\n * @returns {undefined}\n *   Nothing.\n */\nfunction all(state, nest, node, tree) {\n  const fromParent = combine(nest.descendant, nest.directChild)\n  /** @type {Array<AstRule> | undefined} */\n  let fromSibling\n  let index = -1\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n  const total = {count: 0, types: new Map()}\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n  const before = {count: 0, types: new Map()}\n\n  while (++index < node.children.length) {\n    count(total, node.children[index])\n  }\n\n  index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name =\n      child.type === 'element' ? child.tagName.toUpperCase() : undefined\n    // Before counting further elements:\n    state.elementIndex = before.count\n    state.typeIndex = name ? before.types.get(name) || 0 : 0\n    // After counting all elements.\n    state.elementCount = total.count\n    state.typeCount = name ? total.types.get(name) : 0\n\n    // Only apply if this is a parent, this should be an element, but we check\n    // for parents so that we delve into custom nodes too.\n    if ('children' in child) {\n      const forSibling = combine(fromParent, fromSibling)\n      const nest = one(\n        state,\n        forSibling,\n        node.children[index],\n        index,\n        node,\n        tree\n      )\n      fromSibling = combine(nest.generalSibling, nest.adjacentSibling)\n    }\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    count(before, node.children[index])\n  }\n}\n\n/**\n * Apply selectors to an element.\n *\n * @param {State} state\n *   Current state.\n * @param {Array<AstRule>} rules\n *   Rules to apply.\n * @param {Element} node\n *   Element to apply rules to.\n * @param {number | undefined} index\n *   Index of `node` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Nest}\n *   Further rules.\n */\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    adjacentSibling: undefined,\n    descendant: undefined,\n    directChild: undefined,\n    generalSibling: undefined\n  }\n  let selectorIndex = -1\n\n  while (++selectorIndex < rules.length) {\n    const rule = rules[selectorIndex]\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    // When shallow, we dont allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n    if (state.shallow && rule.nestedRule) {\n      throw new Error('Expected selector without nesting')\n    }\n\n    // If this rule matches:\n    if (test(rule, node, index, parent, state)) {\n      const nest = rule.nestedRule\n\n      // Are there more?\n      if (nest) {\n        /** @type {keyof Nest} */\n        const label =\n          nest.combinator === '+'\n            ? 'adjacentSibling'\n            : nest.combinator === '~'\n            ? 'generalSibling'\n            : nest.combinator === '>'\n            ? 'directChild'\n            : 'descendant'\n        add(nestResult, label, nest)\n      } else {\n        // We have a match!\n        state.found = true\n\n        if (!state.results.includes(node)) {\n          state.results.push(node)\n        }\n      }\n    }\n\n    // Descendant.\n    if (rule.combinator === undefined) {\n      add(nestResult, 'descendant', rule)\n    }\n    // Adjacent.\n    else if (rule.combinator === '~') {\n      add(nestResult, 'generalSibling', rule)\n    }\n    // Drop direct child (`>`), adjacent sibling (`+`).\n  }\n\n  return nestResult\n}\n\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<AstRule> | undefined} left\n *   Rules.\n * @param {Array<AstRule> | undefined} right\n *   Rules.\n * @returns {Array<AstRule>}\n *   Rules.\n */\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0\n    ? [...left, ...right]\n    : left && left.length > 0\n    ? left\n    : right && right.length > 0\n    ? right\n    : empty\n}\n\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Nodes} node\n *   Node (were looking for elements).\n * @returns {undefined}\n *   Nothing.\n */\nfunction count(counts, node) {\n  if (node.type === 'element') {\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = node.tagName.toUpperCase()\n    const count = (counts.types.get(name) || 0) + 1\n    counts.count++\n    counts.types.set(name, count)\n  }\n}\n\n/**\n * Check a node.\n *\n * @param {State} state\n *   State.\n * @param {Array<AstRule>} currentRules\n *   Rules.\n * @param {Nodes} node\n *   Node.\n * @param {number | undefined} index\n *   Index of `node` in `parent`.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {Nodes} tree\n *   Tree.\n * @returns {Nest}\n *   Nesting.\n */\nfunction one(state, currentRules, node, index, parent, tree) {\n  /** @type {Nest} */\n  let nestResult = {\n    adjacentSibling: undefined,\n    descendant: undefined,\n    directChild: undefined,\n    generalSibling: undefined\n  }\n\n  const exit = enterState(state, node)\n\n  if (node.type === 'element') {\n    let rootRules = state.rootQuery.rules\n\n    // Remove direct child rules if this is the root.\n    // This only happens for a `:has()` rule, which can be like\n    // `a:has(> b)`.\n    if (parent && parent !== tree) {\n      rootRules = state.rootQuery.rules.filter(\n        (d) =>\n          d.combinator === undefined ||\n          (d.combinator === '>' && parent === tree)\n      )\n    }\n\n    nestResult = applySelectors(\n      state,\n      // Try the root rules for this element too.\n      combine(currentRules, rootRules),\n      node,\n      index,\n      parent\n    )\n  }\n\n  // If this is a parent, and we want to delve into them, and we havent found\n  // our single result yet.\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node, tree)\n  }\n\n  exit()\n\n  return nestResult\n}\n", "/**\n * @typedef {import('css-selector-parser').AstSelector} AstSelector\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {'html' | 'svg'} Space\n *   Name of namespace.\n *\n * @typedef {'auto' | 'ltr' | 'rtl'} Direction\n *   Direction.\n *\n * @typedef State\n *   Current state.\n * @property {Direction} direction\n *   Current direction.\n * @property {boolean} editableOrEditingHost\n *   Whether were in `contentEditable`.\n * @property {number | undefined} elementCount\n *   Track siblings: there are `n` siblings.\n * @property {number | undefined} elementIndex\n *   Track siblings: this current element has `n` elements before it.\n * @property {boolean} found\n *   Whether we found at least one match.\n * @property {string | undefined} language\n *   Current language.\n * @property {boolean} one\n *   Whether we can stop looking after we found one element.\n * @property {Array<Element>} results\n *   Matches.\n * @property {AstSelector} rootQuery\n *   Original root selectors.\n * @property {Schema} schema\n *   Current schema.\n * @property {Array<RootContent>} scopeElements\n *   Elements in scope.\n * @property {boolean} shallow\n *   Whether we only allow selectors without nesting.\n * @property {number | undefined} typeCount\n *   Track siblings: there are `n` siblings with this elements tag name.\n * @property {number | undefined} typeIndex\n *   Track siblings: this current element has `n` elements with its tag name\n *   before it.\n */\n\nimport {html, svg} from 'property-information'\nimport {parse} from './parse.js'\nimport {walk} from './walk.js'\n\n/**\n * Check that the given `node` matches `selector`.\n *\n * This only checks the element itself, not the surrounding tree.\n * Thus, nesting in selectors is not supported (`p b`, `p > b`), neither are\n * selectors like `:first-child`, etc.\n * This only checks that the given element matches the selector.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Nodes | null | undefined} [node]\n *   Node that might match `selector`, should be an element (optional).\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (default: `'html'`).\n * @returns {boolean}\n *   Whether `node` matches `selector`.\n */\nexport function matches(selector, node, space) {\n  const state = createState(selector, node, space)\n  state.one = true\n  state.shallow = true\n  walk(state, node || undefined)\n  return state.results.length > 0\n}\n\n/**\n * Select the first element that matches `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Nodes | null | undefined} [tree]\n *   Tree to search (optional).\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (default: `'html'`).\n * @returns {Element | undefined}\n *   First element in `tree` that matches `selector` or `undefined` if nothing\n *   is found; this could be `tree` itself.\n */\nexport function select(selector, tree, space) {\n  const state = createState(selector, tree, space)\n  state.one = true\n  walk(state, tree || undefined)\n  return state.results[0]\n}\n\n/**\n * Select all elements that match `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Nodes | null | undefined} [tree]\n *   Tree to search (optional).\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (default: `'html'`).\n * @returns {Array<Element>}\n *   Elements in `tree` that match `selector`.\n *   This could include `tree` itself.\n */\nexport function selectAll(selector, tree, space) {\n  const state = createState(selector, tree, space)\n  walk(state, tree || undefined)\n  return state.results\n}\n\n/**\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Nodes | null | undefined} [tree]\n *   Tree to search (optional).\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (default: `'html'`).\n * @returns {State} State\n *   State.\n */\nfunction createState(selector, tree, space) {\n  return {\n    direction: 'ltr',\n    editableOrEditingHost: false,\n    elementCount: undefined,\n    elementIndex: undefined,\n    found: false,\n    language: undefined,\n    one: false,\n    // State of the query.\n    results: [],\n    rootQuery: parse(selector),\n    schema: space === 'svg' ? svg : html,\n    scopeElements: tree ? (tree.type === 'root' ? tree.children : [tree]) : [],\n    shallow: false,\n    typeIndex: undefined,\n    typeCount: undefined\n  }\n}\n"],
  "mappings": "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",
  "names": ["type", "is", "count", "_a", "_b", "className", "__assign", "parse", "lang", "dir", "parse", "stringify", "matches", "name", "name", "whitespace", "parse", "boolbase", "parse", "nthCheck", "empty", "name", "nest", "count", "parse"]
}
