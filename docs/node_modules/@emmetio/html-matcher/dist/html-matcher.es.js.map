{"version":3,"file":"html-matcher.es.js","sources":["../src/utils.ts","../src/attributes.ts","../src/scan.ts","../src/index.ts"],"sourcesContent":["import Scanner, { isSpace, isQuote, isAlpha, isNumber, eatPair } from '@emmetio/scanner';\n\nexport type FastScanCallback = (name: string, type: ElementType, start: number, end: number) => false | any;\n\nexport const enum ElementType {\n    Open = 1,\n    Close = 2,\n    SelfClose = 3,\n    CData = 4,\n    ProcessingInstruction = 5,\n    Comment = 6,\n    ERB = 7,\n}\n\nexport interface SpecialType {\n    [tagName: string]: string[] | null;\n}\n\nexport const enum Chars {\n    /** `-` character */\n    Dash = 45,\n    /** `.` character */\n    Dot = 46,\n    /** `/` character */\n    Slash = 47,\n    /** `:` character */\n    Colon = 58,\n    /** `<` character */\n    LeftAngle = 60,\n    /** `>` character */\n    RightAngle = 62,\n    /** `(` character */\n    LeftRound = 40,\n    /** `)` character */\n    RightRound = 41,\n    /** `[` character */\n    LeftSquare = 91,\n    /** `]` character */\n    RightSquare = 93,\n    /** `{` character */\n    LeftCurly = 123,\n    /** `}` character */\n    RightCurly = 125,\n    /** `_` character */\n    Underscore = 95,\n    /** `=` character */\n    Equals = 61,\n    /** `*` character */\n    Asterisk = 42,\n    /** `#` character */\n    Hash = 35,\n}\n\nexport interface ScannerOptions {\n    /**\n     * Parses given source as XML document. It alters how should-be-empty\n     * elements are treated: for example, in XML mode parser will try to locate\n     * closing pair for `<br>` tag\n     */\n    xml: boolean;\n\n    /**\n     * List of tags that should have special parsing rules, e.g. should not parse\n     * inner content and skip to closing tag. Key is a tag name that should be\n     * considered special and value is either empty (always mark element as special)\n     * or list of `type` attribute values, which, if present with one of this value,\n     * make element special\n     */\n    special: SpecialType;\n\n    /**\n     * List of elements that should be treated as empty (e.g. without closing tag)\n     * in non-XML syntax\n     */\n    empty: string[];\n\n    /**\n     * If enabled, scanner callback will receive XML tokes, including comment, cdata\n     * and processing instructions. If disabled, only tags are emitted\n     */\n    allTokens: boolean;\n}\n\nconst defaultOptions: ScannerOptions = {\n    xml: false,\n    allTokens: false,\n    special: {\n        style: null,\n        script: ['', 'text/javascript', 'application/x-javascript', 'javascript', 'typescript', 'ts', 'coffee', 'coffeescript']\n    },\n    empty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr', 'col', 'embed', 'input', 'param', 'source', 'track']\n};\n\n/** Options for `Scanner` utils */\nexport const opt = { throws: false };\n\nexport function createOptions(options: Partial<ScannerOptions> = {}): ScannerOptions {\n    return { ...defaultOptions, ...options };\n}\n\n/**\n * Converts given string into array of character codes\n */\nexport function toCharCodes(str: string): number[] {\n    return str.split('').map(ch => ch.charCodeAt(0));\n}\n\n/**\n * Consumes array of character codes from given scanner\n */\nexport function consumeArray(scanner: Scanner, codes: number[]): boolean {\n    const start = scanner.pos;\n\n    for (let i = 0; i < codes.length; i++) {\n        if (!scanner.eat(codes[i])) {\n            scanner.pos = start;\n            return false;\n        }\n    }\n\n    scanner.start = start;\n    return true;\n}\n\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @return Returns `true` if section was consumed\n */\nexport function consumeSection(scanner: Scanner, open: number[], close: number[], allowUnclosed?: boolean): boolean {\n    const start = scanner.pos;\n    if (consumeArray(scanner, open)) {\n        // consumed `<!--`, read next until we find ending part or reach the end of input\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, close)) {\n                scanner.start = start;\n                return true;\n            }\n\n            scanner.pos++;\n        }\n\n        // unclosed section is allowed\n        if (allowUnclosed) {\n            scanner.start = start;\n            return true;\n        }\n\n        scanner.pos = start;\n        return false;\n    }\n\n    // unable to find section, revert to initial position\n    scanner.pos = start;\n    return false;\n}\n\n/**\n * Check if given character can be used as a start of tag name or attribute\n */\nexport function nameStartChar(ch: number): boolean {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameStartChar\n    return isAlpha(ch) || ch === Chars.Colon || ch === Chars.Underscore\n        || (ch >= 0xC0 && ch <= 0xD6)\n        || (ch >= 0xD8 && ch <= 0xF6)\n        || (ch >= 0xF8 && ch <= 0x2FF)\n        || (ch >= 0x370 && ch <= 0x37D)\n        || (ch >= 0x37F && ch <= 0x1FFF);\n}\n\n/**\n * Check if given character can be used in a tag or attribute name\n */\nexport function nameChar(ch: number) {\n    // Limited XML spec: https://www.w3.org/TR/xml/#NT-NameChar\n    return nameStartChar(ch) || ch === Chars.Dash || ch === Chars.Dot || isNumber(ch)\n        || ch === 0xB7\n        || (ch >= 0x0300 && ch <= 0x036F);\n}\n\n/**\n * Consumes identifier from given scanner\n */\nexport function ident(scanner: Scanner): boolean {\n    const start = scanner.pos;\n    if (scanner.eat(nameStartChar)) {\n        scanner.eatWhile(nameChar);\n        scanner.start = start;\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Check if given code is tag terminator\n */\nexport function isTerminator(code: number): boolean {\n    return code === Chars.RightAngle || code === Chars.Slash;\n}\n\n/**\n * Check if given character code is valid unquoted value\n */\nexport function isUnquoted(code: number): boolean {\n    return !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);\n}\n\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @return `true` if paired token was consumed\n */\nexport function consumePaired(scanner: Scanner) {\n    return eatPair(scanner, Chars.LeftAngle, Chars.RightAngle, opt)\n        || eatPair(scanner, Chars.LeftRound, Chars.RightRound, opt)\n        || eatPair(scanner, Chars.LeftSquare, Chars.RightSquare, opt)\n        || eatPair(scanner, Chars.LeftCurly, Chars.RightCurly, opt);\n}\n\n/**\n * Returns unquoted value of given string\n */\nexport function getUnquotedValue(value: string): string {\n    // Trim quotes\n    if (isQuote(value.charCodeAt(0))) {\n        value = value.slice(1);\n    }\n\n    if (isQuote(value.charCodeAt(value.length - 1))) {\n        value = value.slice(0, -1);\n    }\n\n    return value;\n}\n","import Scanner, { eatQuoted, isSpace } from '@emmetio/scanner';\nimport { Chars, ident, consumePaired, opt, isUnquoted, getUnquotedValue } from './utils';\n\nexport interface AttributeToken {\n    name: string;\n    value?: string;\n    nameStart: number;\n    nameEnd: number;\n    valueStart?: number;\n    valueEnd?: number;\n}\n\n/**\n * Parses given string as list of HTML attributes.\n * @param src A fragment to parse. If `name` argument is provided, it must be an\n * opening tag (`<a foo=\"bar\">`), otherwise it should be a fragment between element\n * name and tag closing angle (`foo=\"bar\"`)\n * @param name Tag name\n */\nexport default function attributes(src: string, name?: string): AttributeToken[] {\n    const result: AttributeToken[] = [];\n    let start = 0;\n    let end = src.length;\n    if (name) {\n        start = name.length + 1;\n        end -= src.slice(-2) === '/>' ? 2 : 1;\n    }\n    const scanner = new Scanner(src, start, end);\n\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            const token: AttributeToken = {\n                name: scanner.current(),\n                nameStart: scanner.start,\n                nameEnd: scanner.pos\n            };\n\n            if (scanner.eat(Chars.Equals) && attributeValue(scanner)) {\n                token.value = scanner.current();\n                token.valueStart = scanner.start;\n                token.valueEnd = scanner.pos;\n            }\n\n            result.push(token);\n        } else {\n            // Do not break on invalid attributes: we are not validating parser\n            scanner.pos++;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Consumes attribute name from given scanner context\n */\nexport function attributeName(scanner: Scanner): boolean {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Asterisk) || scanner.eat(Chars.Hash)) {\n        // Angular-style directives: `<section *ngIf=\"showSection\">`, `<video #movieplayer ...>`\n        ident(scanner);\n        scanner.start = start;\n        return true;\n    }\n\n    // Attribute name could be a regular name or expression:\n    // React-style – `<div {...props}>`\n    // Angular-style – `<div [ng-for]>` or `<div *ng-for>`\n    return consumePaired(scanner) || ident(scanner);\n}\n\n/**\n * Consumes attribute value\n */\nexport function attributeValue(scanner: Scanner) {\n    // Supported attribute values are quoted, React-like expressions (`{foo}`)\n    // or unquoted literals\n    return eatQuoted(scanner, opt) || consumePaired(scanner) || unquoted(scanner);\n}\n\n/**\n * Returns clean (unquoted) value of `name` attribute\n */\nexport function getAttributeValue(attrs: AttributeToken[], name: string): string | undefined {\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (attr.name === name) {\n            return attr.value && getUnquotedValue(attr.value);\n        }\n    }\n}\n\n/**\n * Consumes unquoted value\n */\nfunction unquoted(scanner: Scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isUnquoted)) {\n        scanner.start = start;\n        return true;\n    }\n}\n","import Scanner, { isSpace, eatQuoted } from '@emmetio/scanner';\nimport { FastScanCallback, ElementType, Chars, consumeArray, toCharCodes, isTerminator, consumeSection, ident, SpecialType, ScannerOptions } from './utils';\nimport attributes, { attributeName, attributeValue, getAttributeValue } from './attributes';\n\nconst cdataOpen = toCharCodes('<![CDATA[');\nconst cdataClose = toCharCodes(']]>');\nconst commentOpen = toCharCodes('<!--');\nconst commentClose = toCharCodes('-->');\nconst piStart = toCharCodes('<?');\nconst piEnd = toCharCodes('?>');\nconst erbStart = toCharCodes('<%');\nconst erbEnd = toCharCodes('%>');\n\n/**\n * Performs fast scan of given source code: for each tag found it invokes callback\n * with tag name, its type (open, close, self-close) and range in original source.\n * Unlike regular scanner, fast scanner doesn’t provide info about attributes to\n * reduce object allocations hence increase performance.\n * If `callback` returns `false`, scanner stops parsing.\n * @param special List of “special” HTML tags which should be ignored. Most likely\n * it’s a \"script\" and \"style\" tags.\n */\nexport default function scan(source: string, callback: FastScanCallback, options?: ScannerOptions) {\n    const scanner = new Scanner(source);\n    const special = options ? options.special : null;\n    const allTokens = options ? options.allTokens : false;\n    let type: ElementType;\n    let name: string;\n    let nameStart: number;\n    let nameEnd: number;\n    let nameCodes: number[];\n    let found = false;\n    let piName: string | null = null;\n\n    while (!scanner.eof()) {\n        const start = scanner.pos;\n\n        if (cdata(scanner)) {\n            if (allTokens && callback('#cdata', ElementType.CData, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        } else if (comment(scanner)) {\n            if (allTokens && callback('#comment', ElementType.Comment, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        } else if (erb(scanner)) {\n            if (allTokens && callback('#erb', ElementType.ERB, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        } else if (piName = processingInstruction(scanner)) {\n            if (allTokens && callback(piName, ElementType.ProcessingInstruction, scanner.start, scanner.pos) === false) {\n                break;\n            }\n        } else if (scanner.eat(Chars.LeftAngle)) {\n            // Maybe a tag name?\n            type = scanner.eat(Chars.Slash) ? ElementType.Close : ElementType.Open;\n            nameStart = scanner.pos;\n\n            if (ident(scanner)) {\n                // Consumed tag name\n                nameEnd = scanner.pos;\n                if (type !== ElementType.Close) {\n                    skipAttributes(scanner);\n                    scanner.eatWhile(isSpace);\n                    if (scanner.eat(Chars.Slash)) {\n                        type = ElementType.SelfClose;\n                    }\n                }\n\n                if (scanner.eat(Chars.RightAngle)) {\n                    // Tag properly closed\n                    name = scanner.substring(nameStart, nameEnd);\n                    if (callback(name, type, start, scanner.pos) === false) {\n                        break;\n                    }\n\n                    if (type === ElementType.Open && special && isSpecial(special, name, source, start, scanner.pos)) {\n                        // Found opening tag of special element: we should skip\n                        // scanner contents until we find closing tag\n                        nameCodes = toCharCodes(name);\n                        found = false;\n                        while (!scanner.eof()) {\n                            if (consumeClosing(scanner, nameCodes)) {\n                                found = true;\n                                break;\n                            }\n\n                            scanner.pos++;\n                        }\n\n                        if (found && callback(name, ElementType.Close, scanner.start, scanner.pos) === false) {\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            scanner.pos++;\n        }\n    }\n}\n\n/**\n * Skips attributes in current tag context\n */\nfunction skipAttributes(scanner: Scanner) {\n    while (!scanner.eof()) {\n        scanner.eatWhile(isSpace);\n        if (attributeName(scanner)) {\n            if (scanner.eat(Chars.Equals)) {\n                attributeValue(scanner);\n            }\n        } else if (isTerminator(scanner.peek())) {\n            break;\n        } else {\n            scanner.pos++;\n        }\n    }\n}\n\n/**\n * Consumes closing tag with given name from scanner\n */\nfunction consumeClosing(scanner: Scanner, name: number[]): boolean {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.LeftAngle) && scanner.eat(Chars.Slash) && consumeArray(scanner, name) && scanner.eat(Chars.RightAngle)) {\n        scanner.start = start;\n        return true;\n    }\n\n    scanner.pos = start;\n    return false;\n}\n\n/**\n * Consumes CDATA from given scanner\n */\nfunction cdata(scanner: Scanner): boolean {\n    return consumeSection(scanner, cdataOpen, cdataClose, true);\n}\n\n/**\n * Consumes comments from given scanner\n */\nfunction comment(scanner: Scanner): boolean {\n    return consumeSection(scanner, commentOpen, commentClose, true);\n}\n\n/**\n * Consumes processing instruction from given scanner. If consumed, returns\n * processing instruction name\n */\nfunction processingInstruction(scanner: Scanner): string | null {\n    const start = scanner.pos;\n    if (consumeArray(scanner, piStart) && ident(scanner)) {\n        const name = scanner.current();\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, piEnd)) {\n                break;\n            }\n\n            eatQuoted(scanner) || scanner.pos++;\n        }\n\n        scanner.start = start;\n        return name;\n    }\n\n    scanner.pos = start;\n    return null;\n}\n\n/**\n * Consumes ERB-style entity: `<% ... %>` or `<%= ... %>`\n */\nfunction erb(scanner: Scanner): boolean {\n    const start = scanner.pos;\n    if (consumeArray(scanner, erbStart)) {\n        while (!scanner.eof()) {\n            if (consumeArray(scanner, erbEnd)) {\n                break;\n            }\n\n            eatQuoted(scanner) || scanner.pos++;\n        }\n\n        scanner.start = start;\n        return true;\n    }\n\n    scanner.pos = start;\n    return false;\n}\n\n/**\n * Check if given tag name should be considered as special\n */\nfunction isSpecial(special: SpecialType, name: string, source: string, start: number, end: number): boolean {\n    if (name in special) {\n        const typeValues = special[name];\n        if (!Array.isArray(typeValues)) {\n            return true;\n        }\n\n        const attrs = attributes(source.substring(start + name.length + 1, end - 1));\n        return typeValues.includes(getAttributeValue(attrs, 'type') || '');\n    }\n\n    return false;\n}\n","import { ScannerOptions, ElementType, createOptions } from './utils';\nimport scan from './scan';\nimport attributes, { AttributeToken } from './attributes';\n\nexport { scan, attributes, AttributeToken };\nexport { createOptions, ScannerOptions, ElementType, FastScanCallback } from './utils';\n\ntype TagRange = [number, number];\n\nexport interface MatchedTag {\n    /** Name of matched tag */\n    name: string;\n    /** List of tag attributes */\n    attributes: AttributeToken[];\n    /** Range of opening tag */\n    open: TagRange;\n    /** Range of closing tag. If absent, tag is self-closing */\n    close?: TagRange;\n}\n\nexport interface BalancedTag {\n    /** Name of balanced tag */\n    name: string;\n    /** Range of opening tag */\n    open: TagRange;\n    /** Range of closing tag. If absent, tag is self-closing */\n    close?: TagRange;\n}\n\ninterface Tag {\n    name: string;\n    start: number;\n    end: number;\n}\n\ninterface InwardTag {\n    name: string;\n    ranges: number[];\n    firstChild?: InwardTag;\n}\n\n/**\n * Finds matched tag for given `pos` location in XML/HTML `source`\n */\nexport default function match(source: string, pos: number, opt?: Partial<ScannerOptions>): MatchedTag | null {\n    // Since we expect large input document, we’ll use pooling technique\n    // for storing tag data to reduce memory pressure and improve performance\n    const pool: Tag[] = [];\n    const stack: Tag[] = [];\n    const options = createOptions(opt);\n    let result: MatchedTag | null = null;\n\n    scan(source, (name, type, start, end) => {\n        if (type === ElementType.Open && isSelfClose(name, options)) {\n            // Found empty element in HTML mode, mark is as self-closing\n            type = ElementType.SelfClose;\n        }\n\n        if (type === ElementType.Open) {\n            // Allocate tag object from pool\n            stack.push(allocTag(pool, name, start, end));\n        } else if (type === ElementType.SelfClose) {\n            if (start < pos && pos < end) {\n                // Matched given self-closing tag\n                result = {\n                    name,\n                    attributes: getAttributes(source, start, end, name),\n                    open: [start, end]\n                };\n                return false;\n            }\n        } else {\n            const tag = last(stack);\n            if (tag && tag.name === name) {\n                // Matching closing tag found\n                if (tag.start < pos && pos < end) {\n                    result = {\n                        name,\n                        attributes: getAttributes(source, tag.start, tag.end, name),\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    };\n                    return false;\n                } else if (stack.length) {\n                    // Release tag object for further re-use\n                    releaseTag(pool, stack.pop()!);\n                }\n            }\n        }\n    }, options);\n\n    stack.length = pool.length = 0;\n    return result;\n}\n\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in outward direction\n */\nexport function balancedOutward(source: string, pos: number, opt?: Partial<ScannerOptions>): BalancedTag[] {\n    const pool: Tag[] = [];\n    const stack: Tag[] = [];\n    const options = createOptions(opt);\n    const result: BalancedTag[] = [];\n\n    scan(source, (name, type, start, end) => {\n        if (type === ElementType.Close) {\n            const tag = last(stack);\n            if (tag && tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.start < pos && pos < end) {\n                    result.push({\n                        name,\n                        open: [tag.start, tag.end],\n                        close: [start, end]\n                    });\n                }\n                // Release tag object for further re-use\n                releaseTag(pool, stack.pop()!);\n            }\n        } else if (type === ElementType.SelfClose || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag\n                result.push({ name, open: [start, end] });\n            }\n        } else {\n            stack.push(allocTag(pool, name, start, end));\n        }\n    }, options);\n\n    stack.length = pool.length = 0;\n    return result;\n}\n\n/**\n * Returns balanced tag model: a list of all XML/HTML tags that could possibly match\n * given location when moving in inward direction\n */\nexport function balancedInward(source: string, pos: number, opt?: Partial<ScannerOptions>): BalancedTag[] {\n    // Collecting tags for inward balancing is a bit trickier: we have to store\n    // first child of every matched tag until we find the one that matches given\n    // location\n    const pool: InwardTag[] = [];\n    const stack: InwardTag[] = [];\n    const options = createOptions(opt);\n    const result: BalancedTag[] = [];\n\n    const alloc = (name: string, start: number, end: number): InwardTag => {\n        if (pool.length) {\n            const tag = pool.pop()!;\n            tag.name = name;\n            tag.ranges.push(start, end);\n            return tag;\n        }\n\n        return { name, ranges: [start, end] };\n    };\n\n    const release = (tag: InwardTag) => {\n        tag.ranges.length = 0;\n        tag.firstChild = void 0;\n        pool.push(tag);\n    };\n\n    scan(source, (name, type, start, end) => {\n        if (type === ElementType.Close) {\n            if (!stack.length) {\n                // Some sort of lone closing tag, ignore it\n                return;\n            }\n\n            let tag = last(stack)!;\n            if (tag.name === name) { // XXX check for invalid tag names?\n                // Matching closing tag found, check if matched pair is a candidate\n                // for outward balancing\n                if (tag.ranges[0] <= pos && pos <= end) {\n                    result.push({\n                        name,\n                        open: tag.ranges.slice(0, 2) as TagRange,\n                        close: [start, end]\n                    });\n\n                    while (tag.firstChild) {\n                        const child = tag.firstChild;\n                        const res: BalancedTag = {\n                            name: child.name,\n                            open: child.ranges.slice(0, 2) as TagRange\n                        };\n                        if (child.ranges.length > 2) {\n                            res.close = child.ranges.slice(2, 4) as TagRange;\n                        }\n                        result.push(res);\n                        release(tag);\n                        tag = child;\n                    }\n\n                    return false;\n                } else {\n                    stack.pop();\n                    const parent = last(stack);\n                    if (parent && !parent.firstChild) {\n                        // No first child in parent node: store current tag\n                        tag.ranges.push(start, end);\n                        parent.firstChild = tag;\n                    } else {\n                        release(tag);\n                    }\n                }\n            }\n        } else if (type === ElementType.SelfClose || isSelfClose(name, options)) {\n            if (start < pos && pos < end) {\n                // Matched self-closed tag, no need to look further\n                result.push({ name, open: [start, end] });\n                return false;\n            }\n\n            const parent = last(stack);\n            if (parent && !parent.firstChild) {\n                parent.firstChild = alloc(name, start, end);\n            }\n        } else {\n            stack.push(alloc(name, start, end));\n        }\n    }, options);\n\n    stack.length = pool.length = 0;\n    return result;\n}\n\nfunction allocTag(pool: Tag[], name: string, start: number, end: number): Tag {\n    if (pool.length) {\n        const tag = pool.pop()!;\n        tag.name = name;\n        tag.start = start;\n        tag.end = end;\n        return tag;\n    }\n    return { name, start, end };\n}\n\nfunction releaseTag(pool: Tag[], tag: Tag) {\n    pool.push(tag);\n}\n\n/**\n * Returns parsed attributes from given source\n */\nfunction getAttributes(source: string, start: number, end: number, name?: string): AttributeToken[] {\n    const tokens = attributes(source.slice(start, end), name);\n    tokens.forEach(attr => {\n        attr.nameStart += start;\n        attr.nameEnd += start;\n        if (attr.value != null) {\n            attr.valueStart! += start;\n            attr.valueEnd! += start;\n        }\n    });\n\n    return tokens;\n}\n\n/**\n * Check if given tag is self-close for current parsing context\n */\nfunction isSelfClose(name: string, options: ScannerOptions) {\n    return !options.xml && options.empty.includes(name);\n}\n\nfunction last<T>(arr: T[]): T | null {\n    return arr.length ? arr[arr.length - 1] : null;\n}\n"],"names":[],"mappings":"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"}