{"version":3,"sources":["../src/hast.ts","../src/internal/escaping.ts"],"sourcesContent":["import type { Element, ElementContent, Node, Nodes, Parent, Parents, Properties, Root } from 'hast'\nimport { toHtml } from 'hast-util-to-html'\nimport { toText } from 'hast-util-to-text'\nimport { matches, select, selectAll } from 'hast-util-select'\nimport { visit } from 'unist-util-visit'\nimport { visitParents, CONTINUE, EXIT, SKIP } from 'unist-util-visit-parents'\nimport { h, s } from 'hastscript'\nimport postcss, { Declaration } from 'postcss'\nimport { serializeCssStringValue } from './internal/escaping'\n\nexport { visit, visitParents, CONTINUE, EXIT, SKIP }\nexport { toHtml, toText, matches, select, selectAll, h, s }\n\nexport type { Element, ElementContent, Node, Nodes, Parent, Parents, Properties, Root }\n\n/**\n * Sets a property on the given AST node.\n *\n * You can set the value to `null` to remove the property.\n */\nexport function setProperty(node: Element, propertyName: string, value: string | string[] | null) {\n\tconst properties: Properties = node.properties || {}\n\tnode.properties = properties\n\tif (value !== null) {\n\t\tproperties[propertyName] = value\n\t} else {\n\t\tdelete properties[propertyName]\n\t}\n}\n\n/**\n * Retrieves an array of class names from the given AST node.\n */\nexport function getClassNames(node: Element): string[] {\n\tconst stringOrArr = node.properties?.className\n\tif (!stringOrArr || stringOrArr === true) return []\n\tif (Array.isArray(stringOrArr)) return stringOrArr.map((className) => className.toString())\n\treturn stringOrArr.toString().split(' ')\n}\n\n/**\n * Adds a class name to the given AST node.\n *\n * If the class name already exists on the node, it will not be added again.\n */\nexport function addClassName(node: Element, className: string) {\n\tconst classNames = getClassNames(node)\n\tif (classNames.indexOf(className) === -1) classNames.push(className)\n\tsetProperty(node, 'className', classNames)\n}\n\n/**\n * Removes a class name from the given AST node.\n *\n * If the class name does not exist on the node, nothing will be changed.\n */\nexport function removeClassName(node: Element, className: string) {\n\tconst classNames = getClassNames(node)\n\tconst index = classNames.indexOf(className)\n\tif (index === -1) return\n\tclassNames.splice(index, 1)\n\tsetProperty(node, 'className', classNames)\n}\n\n/**\n * If the given node has a `style` attribute, parses it and returns a map of its styles.\n *\n * If the node has no `style` attribute, an empty map is returned.\n */\nexport function getInlineStyles(node: Element): Map<string, string> {\n\tconst styles = new Map<string, string>()\n\tconst styleString = node.properties?.style?.toString().trim() || ''\n\tif (!styleString) return styles\n\n\t// @ts-expect-error PostCSS has incorrect types when using exactOptionalPropertyTypes\n\t// eslint-disable-next-line redundant-undefined/redundant-undefined\n\tconst postCssOptions: { from?: string } = { from: undefined }\n\n\t// Attempt to parse the style string and extract its root-level declarations\n\ttry {\n\t\tconst root = postcss.parse(styleString, postCssOptions)\n\n\t\t// Extract all root-level declarations into the styles map\n\t\troot.each((node) => {\n\t\t\tif (node.type === 'decl') styles.set(node.prop, node.value)\n\t\t})\n\t} catch (error) {\n\t\t// Treat invalid inline styles as if they were empty\n\t}\n\n\treturn styles\n}\n\n/**\n * Sets the `style` attribute on the given node to the given styles.\n *\n * Any existing styles will be overwritten.\n */\nexport function setInlineStyles(node: Element, styles: Map<string, string>) {\n\tconst styleString = [...styles]\n\t\t.map(([prop, value]) =>\n\t\t\tnew Declaration({\n\t\t\t\tprop,\n\t\t\t\tvalue,\n\t\t\t\traws: {\n\t\t\t\t\tbetween: ':',\n\t\t\t\t},\n\t\t\t}).toString()\n\t\t)\n\t\t.join(';')\n\tsetProperty(node, 'style', styleString)\n}\n\n/**\n * Sets a single inline style property on the given node.\n *\n * You can set the value to an empty string or `null` to remove the property.\n *\n * Use `valueFormat` to specify how the value should be serialized:\n * - `'raw'`: The value is used as-is. This is the default.\n * - `'string'`: The value is serialized as a CSS string value, escaping special characters.\n */\nexport function setInlineStyle(node: Element, cssProperty: string, value: string | null, valueFormat: 'raw' | 'string' = 'raw') {\n\tconst styles = getInlineStyles(node)\n\tif (value !== null) {\n\t\tstyles.set(cssProperty, valueFormat === 'string' ? serializeCssStringValue(value) : value)\n\t} else {\n\t\tstyles.delete(cssProperty)\n\t}\n\tsetInlineStyles(node, styles)\n}\n","export function escapeRegExp(input: string) {\n\treturn input.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\n/**\n * Serializes the given value as a CSS string value that can be used in `content` or a CSS variable.\n *\n * Special characters are escaped, and the result is wrapped in single or double quotes.\n */\nexport function serializeCssStringValue(value: string, quoteStyle: 'single' | 'double' = 'single') {\n\tconst quote = quoteStyle === 'single' ? \"'\" : '\"'\n\tconst escapedValue = Array.from(value)\n\t\t.map((char) => {\n\t\t\tconst code = char.charCodeAt(0)\n\t\t\tswitch (true) {\n\t\t\t\t// Use replacement character for NULL\n\t\t\t\tcase code === 0x0000:\n\t\t\t\t\treturn '\\uFFFD'\n\t\t\t\t// Escape U+0001 to U+001F and U+007F as code point\n\t\t\t\tcase (code >= 0x0001 && code <= 0x001f) || code === 0x007f:\n\t\t\t\t\treturn `\\\\${code.toString(16)} `\n\t\t\t\t// Escape nested quotes and backslashes\n\t\t\t\tcase char === quote || char === '\\\\':\n\t\t\t\t\treturn `\\\\${char}`\n\t\t\t\t// Use all other characters directly\n\t\t\t\tdefault:\n\t\t\t\t\treturn char\n\t\t\t}\n\t\t})\n\t\t.join('')\n\treturn `${quote}${escapedValue}${quote}`\n}\n"],"mappings":"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","names":["node"]}