{"version":3,"sources":["../../../../node_modules/.pnpm/parse-numeric-range@1.3.0/node_modules/parse-numeric-range/index.js","../src/index.ts","../src/marker-types.ts","../src/styles.ts","../src/utils.ts","../src/inline-markers.ts","../src/annotations.ts"],"sourcesContent":["/**\n * @param {string} string    The string to parse\n * @returns {Array<number>}  Returns an energetic array.\n */\nfunction parsePart(string) {\n  let res = [];\n  let m;\n\n  for (let str of string.split(\",\").map((str) => str.trim())) {\n    // just a number\n    if (/^-?\\d+$/.test(str)) {\n      res.push(parseInt(str, 10));\n    } else if (\n      (m = str.match(/^(-?\\d+)(-|\\.\\.\\.?|\\u2025|\\u2026|\\u22EF)(-?\\d+)$/))\n    ) {\n      // 1-5 or 1..5 (equivalent) or 1...5 (doesn't include 5)\n      let [_, lhs, sep, rhs] = m;\n\n      if (lhs && rhs) {\n        lhs = parseInt(lhs);\n        rhs = parseInt(rhs);\n        const incr = lhs < rhs ? 1 : -1;\n\n        // Make it inclusive by moving the right 'stop-point' away by one.\n        if (sep === \"-\" || sep === \"..\" || sep === \"\\u2025\") rhs += incr;\n\n        for (let i = lhs; i !== rhs; i += incr) res.push(i);\n      }\n    }\n  }\n\n  return res;\n}\n\nexports.default = parsePart;\nmodule.exports = parsePart;\n","import {\n\tAnnotationRenderPhaseOrder,\n\tExpressiveCodePlugin,\n\tInlineStyleAnnotation,\n\tensureColorContrastOnBackground,\n\tgetStaticBackgroundColor,\n\tisInlineStyleAnnotation,\n\tonBackground,\n} from '@expressive-code/core'\nimport rangeParser from 'parse-numeric-range'\nimport type { MarkerType } from './marker-types'\nimport { MarkerTypeOrder, markerTypeFromString } from './marker-types'\nimport { getTextMarkersBaseStyles, markerBgColorPaths, textMarkersStyleSettings } from './styles'\nimport { flattenInlineMarkerRanges, getInlineSearchTermMatches } from './inline-markers'\nimport { TextMarkerAnnotation } from './annotations'\nimport { toDefinitionsArray } from './utils'\nexport type { TextMarkersStyleSettings } from './styles'\n\nexport type MarkerLineOrRange = number | { range: string; label?: string | undefined }\n\n/**\n * A single text marker definition that can be used in the `mark`, `ins`, and `del` props\n * to define text and line markers.\n */\nexport type MarkerDefinition = string | RegExp | MarkerLineOrRange\n\nexport interface PluginTextMarkersProps {\n\t/**\n\t * Defines the code block's [text & line markers](https://expressive-code.com/key-features/text-markers/)\n\t * of the default neutral type.\n\t *\n\t * You can either pass a single marker definition or an array of them.\n\t */\n\tmark: MarkerDefinition | MarkerDefinition[]\n\t/**\n\t * Defines the code block's [text & line markers](https://expressive-code.com/key-features/text-markers/)\n\t * of the \"inserted\" type.\n\t *\n\t * You can either pass a single marker definition or an array of them.\n\t */\n\tins: MarkerDefinition | MarkerDefinition[]\n\t/**\n\t * Defines the code block's [text & line markers](https://expressive-code.com/key-features/text-markers/)\n\t * of the \"deleted\" type.\n\t *\n\t * You can either pass a single marker definition or an array of them.\n\t */\n\tdel: MarkerDefinition | MarkerDefinition[]\n\t/**\n\t * Allows you to enable processing of diff syntax for non-diff languages.\n\t *\n\t * If set to `true`, you can prefix lines with `+` or `-`, no matter what the language of\n\t * the code block is. The prefixes will be removed and the lines will be highlighted as\n\t * inserted or deleted lines.\n\t */\n\tuseDiffSyntax: boolean\n}\n\ndeclare module '@expressive-code/core' {\n\texport interface ExpressiveCodeBlockProps extends PluginTextMarkersProps {}\n}\n\nexport function pluginTextMarkers(): ExpressiveCodePlugin {\n\treturn {\n\t\tname: 'TextMarkers',\n\t\tstyleSettings: textMarkersStyleSettings,\n\t\tbaseStyles: (context) => getTextMarkersBaseStyles(context),\n\t\thooks: {\n\t\t\tpreprocessLanguage: ({ codeBlock }) => {\n\t\t\t\t// If a \"lang\" option was given and the code block's language is \"diff\",\n\t\t\t\t// use the \"lang\" value as the new syntax highlighting language instead\n\t\t\t\t// and set the `useDiffSyntax` prop\n\t\t\t\tconst lang = codeBlock.metaOptions.getString('lang')\n\t\t\t\tif (lang && codeBlock.language === 'diff') {\n\t\t\t\t\tcodeBlock.language = lang\n\t\t\t\t\tcodeBlock.props.useDiffSyntax = true\n\t\t\t\t}\n\t\t\t},\n\t\t\tpreprocessMetadata: ({ codeBlock, cssVar }) => {\n\t\t\t\tconst addDefinition = (target: MarkerType, definition: MarkerDefinition) => {\n\t\t\t\t\tconst definitions = toDefinitionsArray(codeBlock.props[target])\n\t\t\t\t\tdefinitions.push(definition)\n\t\t\t\t\tcodeBlock.props[target] = definitions\n\t\t\t\t}\n\n\t\t\t\t// Transfer meta options (if any) to props\n\t\t\t\tcodeBlock.metaOptions.list([...MarkerTypeOrder, '', 'add', 'rem']).forEach((option) => {\n\t\t\t\t\tconst { kind, key, value } = option\n\t\t\t\t\tconst markerType = markerTypeFromString(key || 'mark')\n\t\t\t\t\tif (!markerType) return\n\n\t\t\t\t\tif (kind === 'string' || kind === 'regexp') addDefinition(markerType, value)\n\t\t\t\t\tif (kind === 'range') {\n\t\t\t\t\t\t// Detect an optional label prefix in double or single quotes: `{\"1\":3-5}`\n\t\t\t\t\t\tlet label: string | undefined = undefined\n\t\t\t\t\t\tconst range = value.replace(/^\\s*?([\"'])([^\\1]+?)\\1:\\s*?/, (_match, _quote, labelValue: string) => {\n\t\t\t\t\t\t\tlabel = labelValue\n\t\t\t\t\t\t\treturn ''\n\t\t\t\t\t\t})\n\t\t\t\t\t\taddDefinition(markerType, { range, label })\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tcodeBlock.props.useDiffSyntax = codeBlock.metaOptions.getBoolean('useDiffSyntax') ?? codeBlock.props.useDiffSyntax\n\n\t\t\t\t// Use props to create line-level annotations for full-line highlighting definitions\n\t\t\t\tMarkerTypeOrder.forEach((markerType) => {\n\t\t\t\t\ttoDefinitionsArray(codeBlock.props[markerType]).forEach((definition) => {\n\t\t\t\t\t\tif (typeof definition === 'string' || definition instanceof RegExp) return\n\t\t\t\t\t\tconst objDefinition = typeof definition === 'number' ? { range: `${definition}` } : definition\n\t\t\t\t\t\tconst { range = '', label } = objDefinition\n\t\t\t\t\t\tconst lineNumbers = rangeParser(range)\n\t\t\t\t\t\tlineNumbers.forEach((lineNumber, idx) => {\n\t\t\t\t\t\t\tconst lineIndex = lineNumber - 1\n\t\t\t\t\t\t\tcodeBlock.getLine(lineIndex)?.addAnnotation(\n\t\t\t\t\t\t\t\tnew TextMarkerAnnotation({\n\t\t\t\t\t\t\t\t\tmarkerType,\n\t\t\t\t\t\t\t\t\tbackgroundColor: cssVar(markerBgColorPaths[markerType]),\n\t\t\t\t\t\t\t\t\t// Add a label to the first line of each consecutive range\n\t\t\t\t\t\t\t\t\tlabel: idx === 0 || lineNumber - lineNumbers[idx - 1] !== 1 ? label : undefined,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t},\n\t\t\tpreprocessCode: ({ codeBlock, cssVar }) => {\n\t\t\t\t// Perform special handling of code marked with the language \"diff\"\n\t\t\t\t// or with the `useDiffSyntax` prop set to true:\n\t\t\t\t// - This language is often used as a widely supported format for highlighting\n\t\t\t\t//   changes to code. In this case, the code is not actually a diff,\n\t\t\t\t//   but another language with some lines prefixed by `+` or `-`.\n\t\t\t\t// - We try to detect this case and convert the prefixed lines to annotations\n\t\t\t\t// - To prevent modifying actual diff files (which would make them invalid),\n\t\t\t\t//   we ensure that the code does not begin like a real diff:\n\t\t\t\t//   - The first lines must not start with `*** `, `+++ `, `--- `, `@@ `,\n\t\t\t\t//     or the default mode location syntax (e.g. `0a1`, `1,2c1,2`, `1,2d1`).\n\t\t\t\tif (codeBlock.language === 'diff' || codeBlock.props.useDiffSyntax) {\n\t\t\t\t\tconst lines = codeBlock.getLines()\n\n\t\t\t\t\t// Ensure that the first lines do not look like actual diff output\n\t\t\t\t\tconst couldBeRealDiffFile = lines.slice(0, 4).some((line) => line.text.match(/^([*+-]{3}\\s|@@\\s|[0-9,]+[acd][0-9,]+\\s*$)/))\n\t\t\t\t\tif (!couldBeRealDiffFile) {\n\t\t\t\t\t\tlet minIndentation = Infinity\n\t\t\t\t\t\tconst parsedLines = lines.map((line) => {\n\t\t\t\t\t\t\tconst [, indentation, marker, content] = line.text.match(/^(([+-](?![+-]))?\\s*)(.*)$/) || []\n\t\t\t\t\t\t\tconst markerType: MarkerType | undefined = marker === '+' ? 'ins' : marker === '-' ? 'del' : undefined\n\n\t\t\t\t\t\t\t// As it's common to indent unchanged lines to match the indentation\n\t\t\t\t\t\t\t// of changed lines, and we don't want extra whitespace in the output,\n\t\t\t\t\t\t\t// we remember the minimum indentation of all non-empty lines\n\t\t\t\t\t\t\tif (content.trim().length > 0 && indentation.length < minIndentation) minIndentation = indentation.length\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tmarkerType,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tparsedLines.forEach(({ line, markerType }) => {\n\t\t\t\t\t\t\t// Remove line prefixes:\n\t\t\t\t\t\t\t// - If minIndentation is > 0, we remove minIndentation\n\t\t\t\t\t\t\t// - Otherwise, if the current line starts with a marker character,\n\t\t\t\t\t\t\t//   we remove this single character\n\t\t\t\t\t\t\tconst colsToRemove = minIndentation || (markerType ? 1 : 0)\n\t\t\t\t\t\t\tif (colsToRemove > 0) line.editText(0, colsToRemove, '')\n\n\t\t\t\t\t\t\t// If we found a diff marker, add a line annotation\n\t\t\t\t\t\t\tif (markerType) {\n\t\t\t\t\t\t\t\tline.addAnnotation(\n\t\t\t\t\t\t\t\t\tnew TextMarkerAnnotation({\n\t\t\t\t\t\t\t\t\t\tmarkerType,\n\t\t\t\t\t\t\t\t\t\tbackgroundColor: cssVar(markerBgColorPaths[markerType]),\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tannotateCode: ({ codeBlock, cssVar }) => {\n\t\t\t\tcodeBlock.getLines().forEach((line) => {\n\t\t\t\t\t// Check the line text for search term matches and collect their ranges\n\t\t\t\t\tconst markerRanges = getInlineSearchTermMatches(line.text, codeBlock)\n\t\t\t\t\tif (!markerRanges.length) return\n\n\t\t\t\t\t// Flatten marked ranges to prevent any overlaps\n\t\t\t\t\tconst flattenedRanges = flattenInlineMarkerRanges(markerRanges)\n\n\t\t\t\t\t// Add annotations for all flattened ranges\n\t\t\t\t\tflattenedRanges.forEach(({ markerType, start, end }) => {\n\t\t\t\t\t\tline.addAnnotation(\n\t\t\t\t\t\t\tnew TextMarkerAnnotation({\n\t\t\t\t\t\t\t\tmarkerType,\n\t\t\t\t\t\t\t\tbackgroundColor: cssVar(markerBgColorPaths[markerType]),\n\t\t\t\t\t\t\t\tinlineRange: {\n\t\t\t\t\t\t\t\t\tcolumnStart: start,\n\t\t\t\t\t\t\t\t\tcolumnEnd: end,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t)\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t},\n\t\t\tpostprocessAnnotations: ({ codeBlock, styleVariants, config }) => {\n\t\t\t\tif (config.minSyntaxHighlightingColorContrast <= 0) return\n\t\t\t\tcodeBlock.getLines().forEach((line) => {\n\t\t\t\t\tconst annotations = line.getAnnotations()\n\t\t\t\t\t// Determine the highest-priority full line marker\n\t\t\t\t\t// and collect all inline markers\n\t\t\t\t\tconst markers: TextMarkerAnnotation[] = []\n\t\t\t\t\tlet fullLineMarker: TextMarkerAnnotation | undefined = undefined\n\t\t\t\t\tfor (const annotation of annotations) {\n\t\t\t\t\t\tif (!(annotation instanceof TextMarkerAnnotation)) continue\n\t\t\t\t\t\tif (annotation.inlineRange) {\n\t\t\t\t\t\t\tmarkers.push(annotation)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fullLineMarker) {\n\t\t\t\t\t\t\tif (MarkerTypeOrder.indexOf(annotation.markerType) < MarkerTypeOrder.indexOf(fullLineMarker.markerType)) continue\n\t\t\t\t\t\t\tif (AnnotationRenderPhaseOrder.indexOf(annotation.renderPhase || 'normal') < AnnotationRenderPhaseOrder.indexOf(fullLineMarker.renderPhase || 'normal')) continue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfullLineMarker = annotation\n\t\t\t\t\t}\n\t\t\t\t\t// Prepend the highest-priority full line marker to the inline markers\n\t\t\t\t\tif (fullLineMarker) markers.unshift(fullLineMarker)\n\t\t\t\t\t// Ensure color contrast for all style variants\n\t\t\t\t\tstyleVariants.forEach((styleVariant, styleVariantIndex) => {\n\t\t\t\t\t\tconst fullLineMarkerBgColor = (fullLineMarker && styleVariant.resolvedStyleSettings.get(markerBgColorPaths[fullLineMarker.markerType])) || 'transparent'\n\t\t\t\t\t\tconst lineBgColor = onBackground(fullLineMarkerBgColor, getStaticBackgroundColor(styleVariant))\n\t\t\t\t\t\t// Collect inline style annotations that change the text color\n\t\t\t\t\t\tconst textColors = annotations.filter(\n\t\t\t\t\t\t\t(annotation) =>\n\t\t\t\t\t\t\t\tisInlineStyleAnnotation(annotation) &&\n\t\t\t\t\t\t\t\tannotation.color &&\n\t\t\t\t\t\t\t\t// Only consider annotations that apply to the current style variant\n\t\t\t\t\t\t\t\t(annotation.styleVariantIndex === undefined || annotation.styleVariantIndex === styleVariantIndex)\n\t\t\t\t\t\t) as InlineStyleAnnotation[]\n\t\t\t\t\t\t// Go through all text color annotations\n\t\t\t\t\t\ttextColors.forEach((textColor) => {\n\t\t\t\t\t\t\tconst textFgColor = textColor.color\n\t\t\t\t\t\t\tconst textStart = textColor.inlineRange?.columnStart\n\t\t\t\t\t\t\tconst textEnd = textColor.inlineRange?.columnEnd\n\t\t\t\t\t\t\tif (textFgColor === undefined || textStart === undefined || textEnd === undefined) return\n\t\t\t\t\t\t\t// Go through all markers\n\t\t\t\t\t\t\tmarkers.forEach((marker) => {\n\t\t\t\t\t\t\t\tconst markerStart = marker.inlineRange?.columnStart ?? 0\n\t\t\t\t\t\t\t\tconst markerEnd = marker.inlineRange?.columnEnd ?? line.text.length\n\t\t\t\t\t\t\t\t// Skip if the marker does not overlap the text color annotation\n\t\t\t\t\t\t\t\tif (markerStart > textEnd || markerEnd < textStart) return\n\t\t\t\t\t\t\t\t// Determine the final background color of the overlapping range,\n\t\t\t\t\t\t\t\t// which is the line background color that may be overlapped by\n\t\t\t\t\t\t\t\t// an inline marker color\n\t\t\t\t\t\t\t\tconst inlineMarkerBgColor = (marker.inlineRange && styleVariant.resolvedStyleSettings.get(markerBgColorPaths[marker.markerType])) || 'transparent'\n\t\t\t\t\t\t\t\tconst combinedBgColor = onBackground(inlineMarkerBgColor, lineBgColor)\n\t\t\t\t\t\t\t\t// Now ensure a good contrast ratio of the text\n\t\t\t\t\t\t\t\tconst readableTextColor = ensureColorContrastOnBackground(textFgColor, combinedBgColor, config.minSyntaxHighlightingColorContrast)\n\t\t\t\t\t\t\t\tif (readableTextColor.toLowerCase() === textFgColor.toLowerCase()) return\n\t\t\t\t\t\t\t\t// If the text color is not readable enough, add an annotation\n\t\t\t\t\t\t\t\t// with better contrast for the overlapping range\n\t\t\t\t\t\t\t\tline.addAnnotation(\n\t\t\t\t\t\t\t\t\tnew InlineStyleAnnotation({\n\t\t\t\t\t\t\t\t\t\tstyleVariantIndex,\n\t\t\t\t\t\t\t\t\t\tinlineRange: {\n\t\t\t\t\t\t\t\t\t\t\tcolumnStart: Math.max(textStart, markerStart),\n\t\t\t\t\t\t\t\t\t\t\tcolumnEnd: Math.min(textEnd, markerEnd),\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tcolor: readableTextColor,\n\t\t\t\t\t\t\t\t\t\trenderPhase: 'earlier',\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t}\n}\n","export type MarkerType = 'mark' | 'ins' | 'del'\n\n/** When markers overlap, those with higher indices override lower ones. */\nexport const MarkerTypeOrder: MarkerType[] = ['mark', 'del', 'ins']\n\n/**\n * If the given input string represents a valid marker type,\n * converts it to a {@link MarkerType} and returns it.\n *\n * Otherwise, returns `undefined`.\n */\nexport function markerTypeFromString(input: string) {\n\t// Fix common marker type mistakes\n\tif (input === 'add') input = 'ins'\n\tif (input === 'rem') input = 'del'\n\n\t// Return either the converted type or undefined\n\tconst markerType = input as MarkerType\n\treturn MarkerTypeOrder.includes(markerType) ? markerType : undefined\n}\n","import { PluginStyleSettings, codeLineClass, toHexColor, StyleSettingPath, ResolverContext, StyleResolverFn } from '@expressive-code/core'\nimport { MarkerType } from './marker-types'\n\nexport interface TextMarkersStyleSettings {\n\t/**\n\t * The margin between the code block border and the line marker accent bar\n\t * displayed on the left side of a full-line text marker.\n\t * @default '0rem'\n\t */\n\tlineMarkerAccentMargin: string\n\t/**\n\t * The width of the line marker accent bar. This is the vertical border-like bar\n\t * displayed on the left side of a full-line text marker.\n\t * @default '0.15rem'\n\t */\n\tlineMarkerAccentWidth: string\n\t/**\n\t * The inline padding (= left & right padding in horizontal writing mode)\n\t * around line marker labels.\n\t *\n\t * @note If your line marker labels overlap with the code content,\n\t * consider increasing the root style setting `codePaddingInline`.\n\t *\n\t * @default '0.2rem'\n\t */\n\tlineMarkerLabelPaddingInline: string\n\t/**\n\t * The text color of the optional labels that can be displayed on the left side\n\t * of a full-line text marker.\n\t * @default 'white'\n\t */\n\tlineMarkerLabelColor: string\n\t/**\n\t * The margin between the code block border and the diff indicator (e.g. `+` or `-`)\n\t * displayed on the left side of a full-line text marker.\n\t * @default '0.3rem'\n\t */\n\tlineDiffIndicatorMarginLeft: string\n\t/**\n\t * The width of the border around inline text markers, rendered in a way\n\t * that does not cause marked code to shift.\n\t * @default '1.5px'\n\t */\n\tinlineMarkerBorderWidth: string\n\t/**\n\t * The border radius of inline text markers.\n\t * @default '0.2rem'\n\t */\n\tinlineMarkerBorderRadius: string\n\t/**\n\t * The inline padding of inline text markers. Keep this low to prevent marked code\n\t * from shifting too much compared to the original text.\n\t * @default '0.15rem'\n\t */\n\tinlineMarkerPadding: string\n\t/**\n\t * The LCH hue to be used for marked text (text marker type `mark`).\n\t * @default '284' (a blue hue)\n\t */\n\tmarkHue: string\n\t/**\n\t * The LCH hue to be used for inserted text (text marker type `ins`).\n\t * @default '136' (a green hue)\n\t */\n\tinsHue: string\n\t/**\n\t * The LCH hue to be used for deleted text (text marker type `del`).\n\t * @default '33' (a red hue)\n\t */\n\tdelHue: string\n\t/**\n\t * The LCH chroma to be used for all text marker types.\n\t *\n\t * The chroma value defines the saturation of the color. Higher values lead to\n\t * more saturated colors, lower values lead to less saturated colors.\n\t *\n\t * @default '40'\n\t */\n\tdefaultChroma: string\n\t/**\n\t * The LCH luminance to be used for all text marker types.\n\t * @default\n\t * ['32%', '75%'] // 32% for dark themes, 75% for light themes\n\t */\n\tdefaultLuminance: string\n\t/**\n\t * The opacity of the background color of all text marker types.\n\t * @default '50%'\n\t */\n\tbackgroundOpacity: string\n\t/**\n\t * The LCH luminance to be used for the border color of all text marker types.\n\t * @default '48%'\n\t */\n\tborderLuminance: string\n\t/**\n\t * The opacity of the border color of all text marker types.\n\t * @default '81.6%'\n\t */\n\tborderOpacity: string\n\t/**\n\t * The LCH luminance to be used for the diff indicator (e.g. `+` or `-`).\n\t * @default\n\t * ['67%', '40%'] // 67% for dark themes, 40% for light themes\n\t */\n\tindicatorLuminance: string\n\t/**\n\t * The opacity of the diff indicator (e.g. `+` or `-`).\n\t * @default '81.6%'\n\t */\n\tindicatorOpacity: string\n\t/**\n\t * The content to be displayed inside the diff indicator of inserted lines.\n\t *\n\t * Note that this is used as the `content` value in a CSS pseudo-element,\n\t * so you need to wrap any text in additional quotes.\n\t *\n\t * @default \"'+'\"\n\t */\n\tinsDiffIndicatorContent: string\n\t/**\n\t * The content to be displayed inside the diff indicator of deleted lines.\n\t *\n\t * Note that this is used as the `content` value in a CSS pseudo-element,\n\t * so you need to wrap any text in additional quotes.\n\t *\n\t * @default \"'-'\"\n\t */\n\tdelDiffIndicatorContent: string\n\t/**\n\t * The background color of marked text (text marker type `mark`).\n\t * @default\n\t * lch(<defaultLuminance> <defaultChroma> <markHue> / <backgroundOpacity>)\n\t */\n\tmarkBackground: string\n\t/**\n\t * The border color of marked text (text marker type `mark`).\n\t * @default\n\t * lch(<borderLuminance> <defaultChroma> <markHue> / <borderOpacity>)\n\t */\n\tmarkBorderColor: string\n\t/**\n\t * The background color of inserted text (text marker type `ins`).\n\t * @default\n\t * lch(<defaultLuminance> <defaultChroma> <insHue> / <backgroundOpacity>)\n\t */\n\tinsBackground: string\n\t/**\n\t * The border color of inserted text (text marker type `ins`).\n\t * @default\n\t * lch(<borderLuminance> <defaultChroma> <insHue> / <borderOpacity>)\n\t */\n\tinsBorderColor: string\n\t/**\n\t * The color of the diff indicator (e.g. `+` or `-`) of inserted lines.\n\t * @default\n\t * lch(<indicatorLuminance> <defaultChroma> <insHue> / <indicatorOpacity>)\n\t */\n\tinsDiffIndicatorColor: string\n\t/**\n\t * The background color of deleted text (text marker type `del`).\n\t * @default\n\t * lch(<defaultLuminance> <defaultChroma> <delHue> / <backgroundOpacity>)\n\t */\n\tdelBackground: string\n\t/**\n\t * The border color of deleted text (text marker type `del`).\n\t * @default\n\t * lch(<borderLuminance> <defaultChroma> <delHue> / <borderOpacity>)\n\t */\n\tdelBorderColor: string\n\t/**\n\t * The color of the diff indicator (e.g. `+` or `-`) of deleted lines.\n\t * @default\n\t * lch(<indicatorLuminance> <defaultChroma> <delHue> / <indicatorOpacity>)\n\t */\n\tdelDiffIndicatorColor: string\n}\n\ndeclare module '@expressive-code/core' {\n\texport interface StyleSettings {\n\t\ttextMarkers: TextMarkersStyleSettings\n\t}\n}\n\nexport const textMarkersStyleSettings = new PluginStyleSettings({\n\tdefaultValues: {\n\t\ttextMarkers: {\n\t\t\tlineMarkerAccentMargin: '0rem',\n\t\t\tlineMarkerAccentWidth: '0.15rem',\n\t\t\tlineMarkerLabelPaddingInline: '0.2rem',\n\t\t\tlineMarkerLabelColor: 'white',\n\t\t\tlineDiffIndicatorMarginLeft: '0.3rem',\n\t\t\tinlineMarkerBorderWidth: '1.5px',\n\t\t\tinlineMarkerBorderRadius: '0.2rem',\n\t\t\tinlineMarkerPadding: '0.15rem',\n\t\t\t// Define base colors for all markers in the LCH color space,\n\t\t\t// which leads to consistent perceived brightness independent of hue\n\t\t\tmarkHue: '284',\n\t\t\tinsHue: '136',\n\t\t\tdelHue: '33',\n\t\t\tdefaultChroma: '40',\n\t\t\tdefaultLuminance: ['32%', '75%'],\n\t\t\tbackgroundOpacity: '50%',\n\t\t\tborderLuminance: '48%',\n\t\t\tborderOpacity: '81.6%',\n\t\t\tindicatorLuminance: ['67%', '40%'],\n\t\t\tindicatorOpacity: '81.6%',\n\t\t\t// You can use these to override the diff indicator content\n\t\t\tinsDiffIndicatorContent: \"'+'\",\n\t\t\tdelDiffIndicatorContent: \"'-'\",\n\t\t\t// The settings below will be calculated based on the settings above\n\t\t\tmarkBackground: (context) => resolveBg(context, 'textMarkers.markHue'),\n\t\t\tmarkBorderColor: (context) => resolveBorder(context, 'textMarkers.markHue'),\n\t\t\tinsBackground: (context) => resolveBg(context, 'textMarkers.insHue'),\n\t\t\tinsBorderColor: (context) => resolveBorder(context, 'textMarkers.insHue'),\n\t\t\tinsDiffIndicatorColor: (context) => resolveIndicator(context, 'textMarkers.insHue'),\n\t\t\tdelBackground: (context) => resolveBg(context, 'textMarkers.delHue'),\n\t\t\tdelBorderColor: (context) => resolveBorder(context, 'textMarkers.delHue'),\n\t\t\tdelDiffIndicatorColor: (context) => resolveIndicator(context, 'textMarkers.delHue'),\n\t\t},\n\t},\n\tcssVarExclusions: [\n\t\t// Exclude all settings from CSS variable output that will not be used directly in styles,\n\t\t// but instead be used to calculate other settings\n\t\t'textMarkers.markHue',\n\t\t'textMarkers.insHue',\n\t\t'textMarkers.delHue',\n\t\t'textMarkers.defaultChroma',\n\t\t'textMarkers.defaultLuminance',\n\t\t'textMarkers.backgroundOpacity',\n\t\t'textMarkers.borderLuminance',\n\t\t'textMarkers.borderOpacity',\n\t\t'textMarkers.indicatorLuminance',\n\t\t'textMarkers.indicatorOpacity',\n\t],\n})\n\nexport function getTextMarkersBaseStyles({ cssVar }: ResolverContext) {\n\tconst result = `\n\t\t.${codeLineClass} {\n\t\t\t/* Support line-level mark/ins/del */\n\t\t\t&.mark {\n\t\t\t\t--tmLineBgCol: ${cssVar('textMarkers.markBackground')};\n\t\t\t\t& .code {\n\t\t\t\t\t--ecLineBrdCol: ${cssVar('textMarkers.markBorderColor')};\n\t\t\t\t}\n\t\t\t}\n\t\t\t&.ins {\n\t\t\t\t--tmLineBgCol: ${cssVar('textMarkers.insBackground')};\n\t\t\t\t--tmLabel: ${cssVar('textMarkers.insDiffIndicatorContent')};\n\t\t\t\t& .code {\n\t\t\t\t\t--ecLineBrdCol: ${cssVar('textMarkers.insBorderColor')};\n\t\t\t\t\t&::before {\n\t\t\t\t\t\tcolor: ${cssVar('textMarkers.insDiffIndicatorColor')};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t&.del {\n\t\t\t\t--tmLineBgCol: ${cssVar('textMarkers.delBackground')};\n\t\t\t\t--tmLabel: ${cssVar('textMarkers.delDiffIndicatorContent')};\n\t\t\t\t& .code {\n\t\t\t\t\t--ecLineBrdCol: ${cssVar('textMarkers.delBorderColor')};\n\t\t\t\t\t&::before {\n\t\t\t\t\t\tcolor: ${cssVar('textMarkers.delDiffIndicatorColor')};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t&.mark,\n\t\t\t&.ins,\n\t\t\t&.del {\n\t\t\t\tbackground: var(--tmLineBgCol);\n\n\t\t\t\t& .code {\n\t\t\t\t\t--ecGtrBrdWd: ${cssVar('textMarkers.lineMarkerAccentWidth')};\n\t\t\t\t}\n\t\t\t\t& .code::before {\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\tleft: 0;\n\t\t\t\t\tbox-sizing: border-box;\n\t\t\t\t\tcontent: var(--tmLabel, ' ');\n\t\t\t\t\tpadding-inline-start: ${cssVar('textMarkers.lineDiffIndicatorMarginLeft')};\n\t\t\t\t\ttext-align: center;\n\t\t\t\t\t/* Prevent long labels from wrapping to avoid overlapping the code */\n\t\t\t\t\twhite-space: pre;\n\t\t\t\t}\n\n\t\t\t\t&.tm-label {\n\t\t\t\t\t& .code::before {\n\t\t\t\t\t\tbackground: var(--ecLineBrdCol);\n\t\t\t\t\t\tpadding: 0 calc(${cssVar('textMarkers.lineMarkerLabelPaddingInline')} + ${cssVar('textMarkers.lineMarkerAccentWidth')}) 0 ${cssVar('textMarkers.lineMarkerLabelPaddingInline')};\n\t\t\t\t\t\tcolor: ${cssVar('textMarkers.lineMarkerLabelColor')};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Support inline mark/ins/del */\n\t\t\t& mark {\n\t\t\t\t--tmInlineBgCol: ${cssVar('textMarkers.markBackground')};\n\t\t\t\t--tmInlineBrdCol: ${cssVar('textMarkers.markBorderColor')};\n\t\t\t}\n\t\t\t& ins {\n\t\t\t\t--tmInlineBgCol: ${cssVar('textMarkers.insBackground')};\n\t\t\t\t--tmInlineBrdCol: ${cssVar('textMarkers.insBorderColor')};\n\t\t\t}\n\t\t\t& del {\n\t\t\t\t--tmInlineBgCol: ${cssVar('textMarkers.delBackground')};\n\t\t\t\t--tmInlineBrdCol: ${cssVar('textMarkers.delBorderColor')};\n\t\t\t}\n\t\t\t& mark,\n\t\t\t& ins,\n\t\t\t& del {\n\t\t\t\tall: unset;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\tposition: relative;\n\t\t\t\t--tmBrdL: ${cssVar('textMarkers.inlineMarkerBorderWidth')};\n\t\t\t\t--tmBrdR: ${cssVar('textMarkers.inlineMarkerBorderWidth')};\n\t\t\t\t--tmRadL: ${cssVar('textMarkers.inlineMarkerBorderRadius')};\n\t\t\t\t--tmRadR: ${cssVar('textMarkers.inlineMarkerBorderRadius')};\n\t\t\t\tmargin-inline: 0.025rem;\n\t\t\t\tpadding-inline: ${cssVar('textMarkers.inlineMarkerPadding')};\n\t\t\t\tborder-radius: var(--tmRadL) var(--tmRadR) var(--tmRadR) var(--tmRadL);\n\t\t\t\tbackground: var(--tmInlineBgCol);\n\t\t\t\tbackground-clip: padding-box;\n\n\t\t\t\t&.open-start {\n\t\t\t\t\tmargin-inline-start: 0;\n\t\t\t\t\tpadding-inline-start: 0;\n\t\t\t\t\t--tmBrdL: 0px;\n\t\t\t\t\t--tmRadL: 0;\n\t\t\t\t}\n\t\t\t\t&.open-end {\n\t\t\t\t\tmargin-inline-end: 0;\n\t\t\t\t\tpadding-inline-end: 0;\n\t\t\t\t\t--tmBrdR: 0px;\n\t\t\t\t\t--tmRadR: 0;\n\t\t\t\t}\n\t\t\t\t&::before {\n\t\t\t\t\tcontent: '';\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\tpointer-events: none;\n\t\t\t\t\tdisplay: inline-block;\n\t\t\t\t\tinset: 0;\n\t\t\t\t\tborder-radius: var(--tmRadL) var(--tmRadR) var(--tmRadR) var(--tmRadL);\n\t\t\t\t\tborder: ${cssVar('textMarkers.inlineMarkerBorderWidth')} solid var(--tmInlineBrdCol);\n\t\t\t\t\tborder-inline-width: var(--tmBrdL) var(--tmBrdR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`\n\n\treturn result\n}\n\nexport const markerBgColorPaths: { [K in MarkerType]: StyleSettingPath } = {\n\tmark: 'textMarkers.markBackground',\n\tins: 'textMarkers.insBackground',\n\tdel: 'textMarkers.delBackground',\n}\n\nfunction resolveBg({ resolveSetting: r }: Parameters<StyleResolverFn>[0], hue: StyleSettingPath) {\n\treturn toHexColor(`lch(${r('textMarkers.defaultLuminance')} ${r('textMarkers.defaultChroma')} ${r(hue)} / ${r('textMarkers.backgroundOpacity')})`)\n}\n\nfunction resolveBorder({ resolveSetting: r }: Parameters<StyleResolverFn>[0], hue: StyleSettingPath) {\n\treturn toHexColor(`lch(${r('textMarkers.borderLuminance')} ${r('textMarkers.defaultChroma')} ${r(hue)} / ${r('textMarkers.borderOpacity')})`)\n}\n\nfunction resolveIndicator({ resolveSetting: r }: Parameters<StyleResolverFn>[0], hue: StyleSettingPath) {\n\treturn toHexColor(`lch(${r('textMarkers.indicatorLuminance')} ${r('textMarkers.defaultChroma')} ${r(hue)} / ${r('textMarkers.indicatorOpacity')})`)\n}\n","import { MarkerDefinition } from '.'\n\n/**\n * Retrieves all group indices from the given RegExp match. Group indices are ranges\n * defined by start & end positions. The first group index refers to the full match,\n * and the following indices to RegExp capture groups (if any).\n *\n * If the RegExp flag `d` was enabled (and supported), it returns the native group indices.\n *\n * Otherwise, it uses fallback logic to manually search for the group contents inside the\n * full match. Note that this can be wrong if a group's contents can be found multiple times\n * inside the full match, but that's probably a rare case and still better than failing.\n */\nexport function getGroupIndicesFromRegExpMatch(match: RegExpMatchArray) {\n\t// Read the start and end ranges from the `indices` property,\n\t// which is made available through the RegExp flag `d`\n\tlet groupIndices = match.indices as ([start: number, end: number] | null)[]\n\tif (groupIndices?.length) return groupIndices\n\n\t// We could not access native group indices, so we need to use fallback logic\n\t// to find the position of each capture group match inside the full match\n\tconst fullMatchIndex = match.index as number\n\tgroupIndices = match.map((groupValue) => {\n\t\tconst groupIndex = groupValue ? match[0].indexOf(groupValue) : -1\n\t\tif (groupIndex === -1) return null\n\t\tconst groupStart = fullMatchIndex + groupIndex\n\t\tconst groupEnd = groupStart + groupValue.length\n\t\treturn [groupStart, groupEnd]\n\t})\n\n\treturn groupIndices\n}\n\nexport function toDefinitionsArray(value: MarkerDefinition | MarkerDefinition[] | undefined) {\n\tif (value === undefined) return []\n\treturn Array.isArray(value) ? value : [value]\n}\n","import { ExpressiveCodeBlock } from '@expressive-code/core'\nimport { MarkerType, MarkerTypeOrder } from './marker-types'\nimport { getGroupIndicesFromRegExpMatch, toDefinitionsArray } from './utils'\n\nexport type InlineMarkerRange = { markerType: MarkerType; start: number; end: number }\n\n/**\n * Goes through all search terms in the given block data and returns an array of\n * inline marker ranges that match the given line text.\n */\nexport function getInlineSearchTermMatches(lineText: string, codeBlock: ExpressiveCodeBlock) {\n\tconst markerMatches: InlineMarkerRange[] = []\n\n\tMarkerTypeOrder.forEach((markerType) => {\n\t\ttoDefinitionsArray(codeBlock.props[markerType]).forEach((definition) => {\n\t\t\t// Handle plaintext string definitions\n\t\t\tif (typeof definition === 'string') {\n\t\t\t\tlet idx = lineText.indexOf(definition, 0)\n\t\t\t\twhile (idx > -1) {\n\t\t\t\t\tmarkerMatches.push({\n\t\t\t\t\t\tmarkerType,\n\t\t\t\t\t\tstart: idx,\n\t\t\t\t\t\tend: idx + definition.length,\n\t\t\t\t\t})\n\t\t\t\t\tidx = lineText.indexOf(definition, idx + definition.length)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Handle regular expression definitions\n\t\t\tif (definition instanceof RegExp) {\n\t\t\t\tconst matches = lineText.matchAll(definition)\n\t\t\t\tfor (const match of matches) {\n\t\t\t\t\tconst rawGroupIndices = getGroupIndicesFromRegExpMatch(match)\n\t\t\t\t\t// Remove null group indices\n\t\t\t\t\tlet groupIndices = rawGroupIndices.flatMap((range) => (range ? [range] : []))\n\t\t\t\t\t// If there are no non-null indices, use the full match instead\n\t\t\t\t\t// (capture group feature fallback, impossible to cover in tests)\n\t\t\t\t\t/* c8 ignore start */\n\t\t\t\t\tif (!groupIndices.length) {\n\t\t\t\t\t\tconst fullMatchIndex = match.index as number\n\t\t\t\t\t\tgroupIndices = [[fullMatchIndex, fullMatchIndex + match[0].length]]\n\t\t\t\t\t}\n\t\t\t\t\t/* c8 ignore end */\n\t\t\t\t\t// If there are multiple non-null indices, remove the first one\n\t\t\t\t\t// as it is the full match and we only want to mark capture groups\n\t\t\t\t\tif (groupIndices.length > 1) {\n\t\t\t\t\t\tgroupIndices.shift()\n\t\t\t\t\t}\n\t\t\t\t\t// Create marked ranges from all remaining group indices\n\t\t\t\t\tgroupIndices.forEach((range) => {\n\t\t\t\t\t\tmarkerMatches.push({\n\t\t\t\t\t\t\tmarkerType,\n\t\t\t\t\t\t\tstart: range[0],\n\t\t\t\t\t\t\tend: range[1],\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n\n\treturn markerMatches\n}\n\n/**\n * Takes an array of inline marker ranges and returns a new array without overlapping ranges,\n * either by merging them into a combined range (if their marker types are the same),\n * or by overriding lower-priority markers with higher-priority ones (if their types differ).\n */\nexport function flattenInlineMarkerRanges(markerRanges: InlineMarkerRange[]): InlineMarkerRange[] {\n\tconst flattenedRanges: InlineMarkerRange[] = []\n\tconst addRange = (newRange: InlineMarkerRange) => {\n\t\tfor (let idx = flattenedRanges.length - 1; idx >= 0; idx--) {\n\t\t\tconst curRange = flattenedRanges[idx]\n\t\t\t// No overlap: The new range ends before the current one starts,\n\t\t\t// or it starts after the current one ends\n\t\t\tif (newRange.end <= curRange.start || newRange.start >= curRange.end) continue\n\n\t\t\t// Full overlap: The new range fully covers the current one\n\t\t\tif (newRange.start <= curRange.start && newRange.end >= curRange.end) {\n\t\t\t\t// Remove current range\n\t\t\t\tflattenedRanges.splice(idx, 1)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Partial overlap with same marker type\n\t\t\tif (newRange.markerType === curRange.markerType) {\n\t\t\t\t// Remove current range and extend the new one to cover it\n\t\t\t\tflattenedRanges.splice(idx, 1)\n\t\t\t\tnewRange = {\n\t\t\t\t\t...newRange,\n\t\t\t\t\tstart: Math.min(newRange.start, curRange.start),\n\t\t\t\t\tend: Math.max(newRange.end, curRange.end),\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If the new range leaves both the start and the end of the current range\n\t\t\t// uncovered, we need to split the current range into two parts\n\t\t\tif (newRange.start > curRange.start && newRange.end < curRange.end) {\n\t\t\t\t// Replace the current range with two partial ranges\n\t\t\t\tflattenedRanges.splice(idx, 1, { ...curRange, end: newRange.start }, { ...curRange, start: newRange.end })\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If the new range starts after the current one starts, shorten the current range\n\t\t\tif (newRange.start > curRange.start) {\n\t\t\t\tcurRange.end = newRange.start\n\t\t\t}\n\n\t\t\t// If the new range ends before the current one ends, shorten the current range\n\t\t\tif (newRange.end < curRange.end) {\n\t\t\t\tcurRange.start = newRange.end\n\t\t\t}\n\t\t}\n\t\t// Finally add the new range to the flattened ranges and sort them by start position\n\t\tflattenedRanges.push(newRange)\n\t\tflattenedRanges.sort((a, b) => a.start - b.start)\n\t}\n\n\tMarkerTypeOrder.forEach((markerType) => {\n\t\tmarkerRanges.filter((range) => range.markerType === markerType).forEach(addRange)\n\t})\n\n\treturn flattenedRanges\n}\n","import { ExpressiveCodeAnnotation, AnnotationBaseOptions, AnnotationRenderOptions } from '@expressive-code/core'\nimport { addClassName, h, setInlineStyle } from '@expressive-code/core/hast'\nimport { MarkerType } from './marker-types'\n\nexport class TextMarkerAnnotation extends ExpressiveCodeAnnotation {\n\tmarkerType: MarkerType\n\tbackgroundColor: string\n\tlabel: string | undefined\n\n\tconstructor({ markerType, backgroundColor, label, ...baseOptions }: { markerType: MarkerType; backgroundColor: string; label?: string | undefined } & AnnotationBaseOptions) {\n\t\tsuper(baseOptions)\n\t\tthis.markerType = markerType\n\t\tthis.backgroundColor = backgroundColor\n\t\tthis.label = label\n\t}\n\n\trender(options: AnnotationRenderOptions) {\n\t\tif (!this.inlineRange) return this.renderFullLineMarker(options)\n\t\treturn this.renderInlineMarker(options)\n\t}\n\n\tprivate renderFullLineMarker({ nodesToTransform }: AnnotationRenderOptions) {\n\t\treturn nodesToTransform.map((node) => {\n\t\t\tif (node.type === 'element') {\n\t\t\t\taddClassName(node, 'highlight')\n\t\t\t\taddClassName(node, this.markerType)\n\t\t\t\tif (this.label) {\n\t\t\t\t\taddClassName(node, 'tm-label')\n\t\t\t\t\tsetInlineStyle(node, '--tmLabel', this.label, 'string')\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node\n\t\t})\n\t}\n\n\tprivate renderInlineMarker({ nodesToTransform }: AnnotationRenderOptions) {\n\t\treturn nodesToTransform.map((node, idx) => {\n\t\t\tconst transformedNode = h(this.markerType, node)\n\n\t\t\tif (nodesToTransform.length > 0 && idx > 0) {\n\t\t\t\taddClassName(transformedNode, 'open-start')\n\t\t\t}\n\t\t\tif (nodesToTransform.length > 0 && idx < nodesToTransform.length - 1) {\n\t\t\t\taddClassName(transformedNode, 'open-end')\n\t\t\t}\n\t\t\treturn transformedNode\n\t\t})\n\t}\n}\n"],"mappings":"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","names":["str","rangeParser"]}