---
title: Validating a Map value
---

import CodeGenContentSwitcher from '../../../components/CodeGenContentSwitcher.astro'

<CodeGenContentSwitcher>
  <div slot="false">
```dart
import 'package:luthor/luthor.dart';

void main() { 
  // Basic map validation
  final validator = l.map();
  print(validator.validateValue({'key': 'value'}));
  
  // Map with key and value validators
  final typedValidator = l.map(
    keyValidator: l.string().required(),
    valueValidator: l.int().required(),
  );
  print(typedValidator.validateValue({
    'key1': 42,
    'key2': 100,
  }));
}
```
  </div>

  <div slot="true">
```dart
import 'package:luthor/luthor.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'map_schema.freezed.dart';
part 'map_schema.g.dart';

@luthor
@freezed
abstract class MapSchema with _$MapSchema {
  const factory MapSchema({
    required Map<String, int> scores,
  }) = _MapSchema;

  factory MapSchema.fromJson(Map<String, dynamic> json) =>
      _$MapSchemaFromJson(json);
}

void main() {
  // Using generated validation function
  final result = $MapSchemaValidate({
    'scores': {
      'player1': 100,
      'player2': 200,
    }
  });

  switch (result) {
    case SchemaValidationSuccess(data: final data):
      print('✅ Valid: ${data.scores}');
    case SchemaValidationError(errors: final errors):
      print('❌ Errors: $errors');
  }
}
```

The code generator automatically creates the map validator:

```dart
// Generated code
Validator $MapSchemaSchema = l.withName('MapSchema').schema({
  MapSchemaSchemaKeys.scores: l.map(
    keyValidator: l.string().required(),
    valueValidator: l.int().required(),
  ),
});

SchemaValidationResult<MapSchema> $MapSchemaValidate(
  Map<String, dynamic> json,
) => $MapSchemaSchema.validateSchema(json, fromJson: MapSchema.fromJson);
```
  </div>
</CodeGenContentSwitcher>

## Key and Value Validation

You can validate both the keys and values of a map using `keyValidator` and `valueValidator` parameters:

```dart
final validator = l.map(
  keyValidator: l.string().required(),
  valueValidator: l.int().required(),
);
```

This ensures that:
- All map keys are valid strings
- All map values are valid integers

## Error Structure

When key or value validation fails, errors are structured as:

```dart
{
  'keys': {
    'key1': ['error messages'],
    'key2': ['error messages'],
  },
  'values': {
    'key1': ['error messages'],
    'key2': ['error messages'],
  }
}
```

This nested structure prevents collisions when your map contains keys named `'keys'` or `'values'`.

## Example with Invalid Data

```dart
final validator = l.map(
  keyValidator: l.int().required(),
  valueValidator: l.string().required(),
);

final result = validator.validateSchema({
  'invalidKey': 'invalidValue', // Both key and value are invalid
});

// Result contains:
// {
//   'keys': {
//     'invalidKey': ['value must be an integer']
//   },
//   'values': {
//     'invalidKey': ['value must be a string']
//   }
// }
```
