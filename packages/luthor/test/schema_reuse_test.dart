import 'package:luthor/luthor.dart';
import 'package:test/test.dart';

void main() {
  group('Schema Reuse Tests', () {
    test(
      'should handle reused schema references with different required states',
      () {
        // This test replicates the exact pattern generated by luthor_generator
        final externalUserSchema = l.withName('ExternalUser').schema({
          'name': l.string().required(),
          'email': l.string().required(),
          'age': l.int(),
        });

        final userProfileSchema = l.withName('UserProfile').schema({
          'id': l.int().required(),
          'user': externalUserSchema
              .required(), // This SHOULD NOT mutate the original
          'user2': externalUserSchema, // This should still be optional
        });

        const data = {
          'id': 1,
          'user': {'name': 'John Doe', 'email': 'john@example.com', 'age': 30},
          // 'user2' is missing - should be OK since not required
        };

        final result = userProfileSchema.validateSchema(data);

        switch (result) {
          case SchemaValidationSuccess(data: _):
            expect(result.data, data);
          case SchemaValidationError(data: _, errors: final errors):
            fail(
              'Should not have errors for missing optional field. Got: $errors',
            );
        }
      },
    );

    test('should handle multiple calls to required() on same schema', () {
      final userSchema = l.withName('User').schema({
        'name': l.string().required(),
        'email': l.string().required(),
      });

      // Multiple calls to .required() should not affect each other
      final schema1 = l.withName('Schema1').schema({
        'user1': userSchema.required(),
        'user2': userSchema, // Should still be optional
        'user3': userSchema.required(),
      });

      const data = {
        'user1': {'name': 'User1', 'email': 'user1@example.com'},
        // user2 missing - should be OK
        'user3': {'name': 'User3', 'email': 'user3@example.com'},
      };

      final result = schema1.validateSchema(data);

      switch (result) {
        case SchemaValidationSuccess(data: _):
          expect(result.data, data);
        case SchemaValidationError(data: _, errors: final errors):
          fail(
            'Should not have errors for missing optional field. Got: $errors',
          );
      }
    });
  });
}
